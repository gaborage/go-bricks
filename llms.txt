# GoBricks Framework

Enterprise Go microservice toolkit (Go 1.24+). Provides multi-database access, typed HTTP handlers, AMQP messaging, tenant isolation, and built-in OpenTelemetry.

## Quick Start
- `go get github.com/gaborage/go-bricks`
- Scaffold:

```go
package main

import (
	"log"

	"github.com/gaborage/go-bricks/app"
	"github.com/gaborage/go-bricks/config"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}
	fw, err := app.NewWithConfig(cfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	fw.RegisterModules(/* modules */)
	log.Fatal(fw.Run())
}
```

## Config Snapshot

```yaml
app:
  name: my-service
  environment: development
server:
  enabled: true
  port: 8080
database:
  type: postgres # postgres | oracle | mongo
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
logger:
  level: info
  pretty: true
```

`Highest precedence first: env vars > config.<env>.yaml > config.yaml > struct defaults.`
Add observability settings as needed (see Observability & Logging).

## Core Concepts
- Framework injects dependencies via `*app.ModuleDeps`; avoid constructing raw `*sql.DB`.
- Declarative messaging defines exchanges, queues, bindings, publishers, and consumers once; the framework replays per tenant.
- Observability hooks (traces, metrics, structured logs) activate when `observability.enabled=true`.
- Multi-tenant mode resolves tenants (header/host/custom store) and hands each module tenant-specific resources.

## Module Skeleton

```go
type Module struct {
	db     database.Interface
	logger logger.Logger
}

func (m *Module) Name() string { return "mymodule" }

func (m *Module) Init(deps *app.ModuleDeps) error {
	m.db = deps.DB
	m.logger = deps.Logger.WithFields(map[string]any{"module": m.Name()})
	return nil
}

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, e *echo.Echo) {
	handler := NewHandler(m.db, m.logger)
	server.POST(hr, e, "/users", handler.Create)
}

func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	// optional
}

func (m *Module) Shutdown() error { return nil }
```

## Typed HTTP Handlers

```go
type CreateUserReq struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required,email"`
}

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (h *Handler) Create(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	reqCtx := ctx.Request().Context()
	user, err := h.svc.Create(reqCtx, req)
	if err != nil {
		return server.Result[User]{}, server.InternalServerError(err)
	}
	return server.Created(user), nil
}
```

| Pattern          | Request binding              | Success helper          | Notes                          |
|------------------|------------------------------|-------------------------|--------------------------------|
| POST create      | JSON struct w/ validators    | `server.Created(data)`  | 422 auto-emitted on validation |
| GET lookup       | `server.NoBody` + `ctx.Param`| `server.OK(data)`       | Return domain errors as API    |
| LIST with query  | `query:"..."` struct tags    | `server.OK(list)`       | Query params auto-bound        |
| DELETE           | `server.NoBody`              | `server.NoContent()`    | Return typed API errors        |
| ASYNC acceptance | Request struct               | `server.Accepted(meta)` | For enqueue-style workflows    |

### Pointer Types for Large Payloads

Use **pointer types** for requests/responses >1KB to eliminate copy overhead. Fully backward compatible.

```go
// Large request - file upload (pointer avoids copying MB of data)
type FileUploadRequest struct {
	Data     []byte `json:"data" validate:"required"` // Base64-encoded file
	Filename string `json:"filename" validate:"required"`
	MimeType string `json:"mime_type"`
}

func (h *Handler) UploadFile(req *FileUploadRequest, ctx server.HandlerContext) (server.Result[UploadResponse], server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	fileID, err := h.storageService.Store(reqCtx, req.Data, req.Filename, req.MimeType)
	if err != nil {
		return server.Result[UploadResponse]{}, server.InternalServerError(err)
	}
	return server.Created(UploadResponse{FileID: fileID, Size: len(req.Data)}), nil
}

// Large response - bulk export (pointer avoids copying thousands of records)
type BulkExportResponse struct {
	Records []Record `json:"records"`
	Total   int      `json:"total"`
	Page    int      `json:"page"`
}

func (h *Handler) ExportRecords(req ExportRequest, ctx server.HandlerContext) (*BulkExportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	records, err := h.recordService.GetAll(reqCtx, req.Filter)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkExportResponse{
		Records: records,
		Total:   len(records),
		Page:    req.Page,
	}, nil
}

// Both pointer types - bulk import handler
type BulkImportRequest struct {
	Records []ImportRecord `json:"records" validate:"required,min=1,max=10000"`
	DryRun  bool           `json:"dry_run"`
}

type BulkImportResponse struct {
	Imported int      `json:"imported"`
	Failed   int      `json:"failed"`
	Errors   []string `json:"errors,omitempty"`
}

func (h *Handler) BulkImport(req *BulkImportRequest, ctx server.HandlerContext) (*BulkImportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	result, err := h.importService.ProcessBulk(reqCtx, req.Records, req.DryRun)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkImportResponse{
		Imported: result.Imported,
		Failed:   result.Failed,
		Errors:   result.Errors,
	}, nil
}
```

**Performance guidelines:**
- **<1KB**: Use value types (default, idiomatic Go)
- **1KB-10KB**: Consider pointers for high-traffic endpoints
- **>10KB**: Always use pointers (file uploads, bulk operations)
- Pointer fields (`*string`, `*int`) work correctly with validation (`omitempty`, `min=`)

## Database Builder & Operations

```go
// Define entity with db tags
type User struct {
    ID     int64  `db:"id"`
    Email  string `db:"email"`
    Status string `db:"status"`
}

qb := builder.NewQueryBuilder(m.db.DatabaseType())
f := qb.Filter()
cols := qb.Columns(&User{})

sql, args := qb.Select(cols.Fields("ID", "Email")...).
	From("users").
	Where(f.And(
		f.Eq(cols.Col("Status"), "active"),
		f.Like(cols.Col("Email"), "%@example.com"),
	)).
	ToSQL()

ctx := context.Background() // or propagate incoming request context
rows, err := m.db.Query(ctx, sql, args...)
```

| Need                | Builder call / API usage                                               |
|---------------------|------------------------------------------------------------------------|
| Filtering           | `f.Eq`, `f.And`, `f.Or`, `f.In`, `f.Between`                           |
| Sorting / grouping  | `qb.Select(...).From("...").OrderBy(qb.Expr("created_at DESC")).GroupBy("tenant_id")` |
| Mutations           | `qb.Insert`, `qb.Update`, `qb.Delete`, then `db.Exec`                  |
| Joins               | `qb.JoinOn` with `qb.JoinFilter()`                                     |
| Subqueries          | Compose another builder clause then `f.Exists(subQuery)`               |
| Transactions        | `tx, err := db.Begin(ctx); if err != nil { return err }; defer tx.Rollback(ctx); /* work */; if err := tx.Commit(ctx); err != nil { return err }` |

**Mutation Examples (INSERT/UPDATE/DELETE):**

```go
// INSERT
sql, args := qb.Insert("users").
    Columns(cols.Col("Name"), cols.Col("Email")).
    Values("Alice", "alice@example.com").
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// UPDATE
sql, args := qb.Update("users").
    Set(cols.Col("Name"), "Bob").
    Set(cols.Col("Email"), "bob@example.com").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// DELETE
sql, args := qb.Delete("users").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)
```

Access to vendor quirks (Oracle quoting, Mongo builders) routes through the same interface; switching drivers requires config only.

**Struct-Based Columns (v0.15.0+):**

```go
// Define entity once with db tags
type User struct {
    ID    int64  `db:"id"`
    Name  string `db:"name"`
    Level int    `db:"level"` // Oracle reserved word - auto-quoted
}

// Extract columns (cached per vendor)
cols := qb.Columns(&User{})

// SELECT with type-safe field references
query := qb.Select(cols.Fields("ID", "Name")...).
    From("users").
    Where(f.Eq(cols.Col("Level"), 5))
// Oracle: SELECT "ID", "NAME" FROM users WHERE "LEVEL" = :1
// PostgreSQL: SELECT id, name FROM users WHERE level = $1

// All columns: cols.All()
// Single column: cols.Col("FieldName")
// Multiple columns: cols.Fields("ID", "Name", "Email")
// Performance: ~0.6µs first parse, ~26ns cached access
```

**Table Aliases with Struct-Based Columns:**

```go
type User struct {
    ID     int64  `db:"id"`
    Name   string `db:"name"`
    Status string `db:"status"`
}

type Account struct {
    ID     int64  `db:"id"`
    Number string `db:"number"` // Oracle reserved word - auto-quoted
}

userCols := qb.Columns(&User{})
acctCols := qb.Columns(&Account{})

// Create aliased instances using As()
u := userCols.As("u")
a := acctCols.As("a")

jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select(
    u.Col("ID"),      // "u.id" or "u.\"ID\"" for Oracle
    u.Col("Name"),    // "u.name" or "u.\"NAME\"" for Oracle
    a.Col("Number"),  // "a.\"NUMBER\"" for Oracle (reserved word)
).
    From(dbtypes.Table("users").As("u")).
    JoinOn(dbtypes.Table("accounts").As("a"),
        jf.EqColumn(u.Col("ID"), a.Col("ID"))).
    Where(f.Eq(u.Col("Status"), "active"))
// Oracle: SELECT u."ID", u."NAME", a."NUMBER" FROM users u JOIN accounts a ON u."ID" = a."ID" WHERE u."STATUS" = :1
```

**Advanced JOIN Patterns:**

```go
// Mixed JOIN conditions: column-to-column + column-to-value with expressions
jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select("*").
    From(dbtypes.Table("orders").As("o")).
    JoinOn(dbtypes.Table("customers").As("c"), jf.And(
        jf.EqColumn("c.id", "o.customer_id"),       // Column-to-column
        jf.Eq("c.status", "active"),                 // Column-to-value
        jf.In("c.tier", []string{"gold", "platinum"}),
    )).
    JoinOn(dbtypes.Table("products").As("p"), jf.And(
        jf.EqColumn("p.id", "o.product_id"),
        jf.Eq("p.price", qb.Expr("TO_NUMBER(o.max_price)")), // Expression support
    )).
    Where(f.Eq("o.status", "pending"))
```

**Window Functions & Aggregations:**

```go
type Product struct {
    ProductID int64   `db:"product_id"`
    Price     float64 `db:"price"`
    Category  string  `db:"category"`
}
cols := qb.Columns(&Product{})

// Window function with PARTITION BY
query := qb.Select(
    cols.Col("ProductID"),
    cols.Col("Price"),
    qb.Expr("ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC)", "rank"),
).From("products")

// Aggregations with GROUP BY
query := qb.Select(
    cols.Col("Category"),
    qb.Expr("COUNT(*)", "product_count"),
    qb.Expr("AVG(price)", "avg_price"),
).From("products").GroupBy(cols.Col("Category"))
```

## Oracle SEQUENCE vs UDT - Important Distinction

### Oracle SEQUENCE Objects (ID Generation)

**SEQUENCE queries work immediately - NO UDT registration required:**

```go
// Get next ID from sequence
var nextID int64
err := conn.QueryRow(ctx, "SELECT SEQ_ID_TABLE.NEXTVAL FROM DUAL").Scan(&nextID)

// Get current sequence value
var currID int64
err := conn.QueryRow(ctx, "SELECT SEQ_ID_TABLE.CURRVAL FROM DUAL").Scan(&currID)

// Use in INSERT statement
_, err = conn.Exec(ctx, "INSERT INTO users (id, name) VALUES (user_seq.NEXTVAL, :1)", name)
```

**Creating sequences in Oracle:**
```sql
CREATE SEQUENCE user_seq START WITH 1000 INCREMENT BY 1;
CREATE SEQUENCE order_seq START WITH 10000 INCREMENT BY 10;
```

### Oracle User-Defined Types (Custom Objects/Collections)

**UDT registration ONLY required for custom types created with CREATE TYPE:**

```go
import "github.com/gaborage/go-bricks/database/oracle"

// 1. Define struct matching Oracle object type
type Product struct {
    ID    int64   `udt:"ID"`       // Must match Oracle field names
    Name  string  `udt:"NAME"`
    Price float64 `udt:"PRICE"`
}

// 2. Type assert to access Oracle-specific methods
oracleConn := conn.(*oracle.Connection)

// 3. Register collection type for bulk operations
err := oracleConn.RegisterType("PRODUCT_TYPE", "PRODUCT_TABLE", Product{})
if err != nil {
    return fmt.Errorf("UDT registration failed: %w", err)
}

// 4. Use in bulk insert
products := []Product{
    {ID: 1, Name: "Widget", Price: 19.99},
    {ID: 2, Name: "Gadget", Price: 29.99},
}

_, err = conn.Exec(ctx, "BEGIN bulk_insert_products(:1); END;", products)
```

**Oracle type definitions:**
```sql
-- Object type
CREATE TYPE PRODUCT_TYPE AS OBJECT (
    ID    NUMBER,
    NAME  VARCHAR2(100),
    PRICE NUMBER(10,2)
);

-- Collection type (TABLE OF = unbounded array)
CREATE TYPE PRODUCT_TABLE AS TABLE OF PRODUCT_TYPE;

-- Stored procedure accepting collection
CREATE OR REPLACE PROCEDURE bulk_insert_products(p_products IN PRODUCT_TABLE) IS
BEGIN
    FORALL i IN INDICES OF p_products
        INSERT INTO products (id, name, price)
        VALUES (p_products(i).ID, p_products(i).NAME, p_products(i).PRICE);
END;
```

### Schema-Qualified UDTs

```go
type Customer struct {
    CustomerID int    `udt:"CUSTOMER_ID"`
    Name       string `udt:"NAME"`
}

oracleConn := conn.(*oracle.Connection)

// Register from specific schema
err := oracleConn.RegisterTypeWithOwner("SHARED_SCHEMA", "CUSTOMER_TYPE", "CUSTOMER_TABLE", Customer{})

customers := []Customer{{CustomerID: 1, Name: "ACME"}, ...}
_, err = conn.Exec(ctx, "BEGIN SHARED_SCHEMA.process_customers(:1); END;", customers)
```

### VARRAY (Bounded Arrays)

For fixed-size arrays:

```sql
-- Oracle: Create bounded array type
CREATE TYPE STATUS_CODES AS VARRAY(10) OF VARCHAR2(20);
```

```go
type StatusCode struct {
    Code string `udt:"CODE"`
}

oracleConn.RegisterType("STATUS_CODE", "STATUS_CODES", StatusCode{})

// Use with bounded array
codes := []StatusCode{
    {Code: "PENDING"},
    {Code: "APPROVED"},
    {Code: "COMPLETED"},
}
```

### Single Object Types (No Collections)

If you only need single object parameters (not arrays):

```go
type Customer struct {
    ID   int    `udt:"ID"`
    Name string `udt:"NAME"`
}

// Register without collection type (arrayTypeName = "")
err := oracleConn.RegisterType("CUSTOMER_TYPE", "", Customer{})

// Use single object in procedure
customer := Customer{ID: 123, Name: "ACME Corp"}
_, err = conn.Exec(ctx, "BEGIN update_customer(:1); END;", customer)
```

### Common Errors

**Error:** `"call register type before use user defined type (UDT)"`
**Cause:** Trying to use custom TYPE in stored procedure without RegisterType()
**Solution:** Call RegisterType() during initialization before using UDT

**Important:** This error does NOT affect SEQUENCE queries - sequences always work without registration

### Key Takeaways

- **SEQUENCE objects** (auto-increment IDs) → No registration needed, standard SQL queries
- **UDT collection types** (TABLE OF, VARRAY) → Requires RegisterType() before use
- **Type assertion required** → Must cast to `*oracle.Connection` to access UDT methods
- **Registration timing** → Call during application initialization, before any UDT queries
- **Tag format** → `udt:` tags must EXACTLY match Oracle field names (case-sensitive, usually uppercase)

## Database Testing

> **⚠️ IMPORTANT RESOURCE MANAGEMENT:**
> When using `Query()` or `TestTx.Query()`, **ALWAYS call `defer rows.Close()`** immediately after obtaining rows.
> The returned `*sql.Rows` is backed by a temporary `*sql.DB` that must be explicitly closed to prevent resource leaks.
> A finalizer provides a safety net, but **explicit cleanup via `defer` is mandatory** for deterministic resource management.

**Simple Query Test:**

```go
import dbtest "github.com/gaborage/go-bricks/database/testing"

func TestProductService_FindActive(t *testing.T) {
    // Setup (8 lines vs 30+ with sqlmock)
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewProductService(deps)
    products, err := svc.FindActive(ctx)

    assert.NoError(t, err)
    assert.Len(t, products, 2)
dbtest.AssertQueryExecuted(t, db, "SELECT")
}
```

**Iterating Rows with `Query`:**

```go
func TestProductRepository_List(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    rows, err := db.Query(context.Background(), "SELECT id, name FROM products")
    require.NoError(t, err)
    defer rows.Close()

    var got []Product
    for rows.Next() {
        var p Product
        require.NoError(t, rows.Scan(&p.ID, &p.Name))
        got = append(got, p)
    }

    require.NoError(t, rows.Err())
    assert.Len(t, got, 2)
}
```

**Transaction Test:**

```go
func TestOrderService_CreateWithItems(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    tx := db.ExpectTransaction().
        ExpectExec("INSERT INTO orders").WillReturnRowsAffected(1).
        ExpectExec("INSERT INTO items").WillReturnRowsAffected(3)

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewOrderService(deps)
    err := svc.CreateWithItems(ctx, order, items)

    assert.NoError(t, err)
    dbtest.AssertCommitted(t, tx)
}
```

**Multi-Tenant Test:**

```go
func TestMultiTenantService(t *testing.T) {
    tenants := dbtest.NewTenantDBMap()

    // Setup tenant-specific expectations
    tenants.ForTenant("acme").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(1)),
        )
    tenants.ForTenant("globex").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(2)),
        )

    deps := &app.ModuleDeps{
        GetDB: tenants.AsGetDBFunc(),  // Resolves tenant from ctx
    }

    // Test with tenant context
    ctx := multitenant.SetTenant(context.Background(), "acme")
    result, err := svc.Process(ctx)

    assert.NoError(t, err)
    dbtest.AssertQueryExecuted(t, tenants.GetTenantDB("acme"), "SELECT")
}
```

**RowSet Builders:**

```go
// From structs with db tags
type User struct {
    ID   int64  `db:"id"`
    Name string `db:"name"`
}

rows := dbtest.NewRowSet("id", "name").
    AddRowsFromStructs(
        &User{ID: 1, Name: "Alice"},
        &User{ID: 2, Name: "Bob"},
    )

// With generator function
rows := dbtest.NewRowSet("id", "name").
    AddRows(100, func(i int) []any {
        return []any{int64(i+1), fmt.Sprintf("User%d", i+1)}
    })

// RowSet powers both Query() and QueryRow() expectations. It now materializes
// real *sql.Rows under the hood, so you can iterate using database/sql's
// standard pattern. Supported value types include integers, floats, bools,
// strings, []byte, time.Time, fmt.Stringer, and nil.
```

**Assertion Helpers:**

```go
dbtest.AssertQueryExecuted(t, db, "SELECT")
dbtest.AssertQueryCount(t, db, "SELECT", 2)
dbtest.AssertExecExecuted(t, db, "INSERT")
dbtest.AssertTransactionCommitted(t, db)
dbtest.AssertTransactionRolledBack(t, db)
```

See [database/testing](database/testing/) package for full API documentation.

## Cache Operations (Redis)

**Configuration:**

```yaml
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
    password: ${CACHE_REDIS_PASSWORD} # from env
    database: 0
    pool_size: 10
```

**CacheManager Lifecycle (Multi-Tenant Applications):**

GoBricks uses CacheManager to handle per-tenant cache instances with automatic lifecycle management:

- **Lazy Initialization:** Cache created on first access per tenant (no upfront connections)
- **LRU Eviction:** Oldest cache evicted when MaxSize exceeded (default: 100 tenants)
- **Idle Cleanup:** Unused caches closed after IdleTTL (default: 15m, checked every 5m)
- **Singleflight:** Prevents duplicate cache creation during concurrent access

```yaml
# Optional: Override CacheManager defaults
cache:
  enabled: true
  manager:
    max_size: 100          # Max tenant cache instances (0 = unlimited)
    idle_ttl: 15m          # Idle timeout per cache
    cleanup_interval: 5m   # Cleanup goroutine frequency
  redis:
    host: localhost
    port: 6379
```

**Manager Statistics:**

```go
// Access manager stats (useful for monitoring)
stats := cacheManager.Stats()  // From app internals

// ManagerStats{
//   ActiveCaches:  45,      // Current active instances
//   TotalCreated:  128,     // Lifetime total
//   Evictions:     12,      // LRU evictions
//   IdleCleanups:  71,      // Timeout cleanups
//   Errors:        0,       // Creation/close errors
//   MaxSize:       100,
//   IdleTTL:       900      // seconds
// }
```

**Module Setup (Multi-Tenant Aware):**

```go
import (
    "context"
    "fmt"
    "time"

    "github.com/gaborage/go-bricks/app"
    "github.com/gaborage/go-bricks/cache"
)

// IMPORTANT: Store GetCache function, NOT cache instance
type Module struct {
    getCache func(context.Context) (cache.Cache, error)
    logger   logger.Logger
}

func (m *Module) Init(deps *app.ModuleDeps) error {
    m.getCache = deps.GetCache  // Store function for tenant-aware resolution
    m.logger = deps.Logger
    return nil
}

// Service method using tenant context
type UserService struct {
    getCache func(context.Context) (cache.Cache, error)
}

func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    // GetCache resolves tenant from context automatically
    cache, err := s.getCache(ctx)
    if err != nil {
        return nil, fmt.Errorf("cache not available: %w", err)
    }

    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first
    data, err := cache.Get(ctx, cacheKey)
    if err == nil {
        return cache.Unmarshal[User](data)
    }

    // Cache miss - query database
    user, err := s.queryDatabase(ctx, id)
    if err != nil {
        return nil, err
    }

    // Store in cache
    data, _ = cache.Marshal(user)
    cache.Set(ctx, cacheKey, data, 5*time.Minute)

    return user, nil
}
```

**Basic Cache Operations:**

```go
// Set with TTL
err := cache.Set(ctx, "user:123", []byte("data"), 5*time.Minute)

// Get
data, err := cache.Get(ctx, "user:123")
if errors.Is(err, cache.ErrNotFound) {
    // Key doesn't exist - fetch from database
}

// Delete
err := cache.Delete(ctx, "user:123")
```

**Custom Cache Configuration Injection:**

```go
import "github.com/gaborage/go-bricks/config"

// Module-specific cache configuration
type CacheConfig struct {
    DefaultTTL time.Duration `config:"custom.cache.default_ttl" default:"5m"`
    KeyPrefix  string        `config:"custom.cache.key_prefix" default:"myapp"`
    MaxRetries int           `config:"custom.cache.max_retries" default:"3"`
}

type Module struct {
    getCache   func(context.Context) (cache.Cache, error)
    defaultTTL time.Duration
    keyPrefix  string
}

func (m *Module) Init(deps *app.ModuleDeps) error {
    // Inject custom cache config from YAML
    var cacheCfg CacheConfig
    if err := deps.Config.InjectInto(&cacheCfg); err != nil {
        return fmt.Errorf("cache config injection failed: %w", err)
    }

    m.getCache = deps.GetCache
    m.defaultTTL = cacheCfg.DefaultTTL
    m.keyPrefix = cacheCfg.KeyPrefix

    deps.Logger.Info("Cache configured",
        "default_ttl", m.defaultTTL,
        "key_prefix", m.keyPrefix)

    return nil
}

// Use injected config in service methods
func (m *Module) CacheUser(ctx context.Context, user *User) error {
    cache, _ := m.getCache(ctx)

    key := fmt.Sprintf("%s:user:%d", m.keyPrefix, user.ID)  // Uses prefix
    data, _ := cache.Marshal(user)

    return cache.Set(ctx, key, data, m.defaultTTL)  // Uses default TTL
}
```

**Configuration (config.yaml):**
```yaml
custom:
  cache:
    default_ttl: 10m      # Override module default
    key_prefix: myservice
    max_retries: 5
```

**Type-Safe Serialization:**

```go
import "github.com/gaborage/go-bricks/cache"

type User struct {
    ID    int64  `cbor:"1,keyasint"` // Optimized: integer keys
    Name  string `cbor:"2,keyasint"`
    Email string `cbor:"3,keyasint"`
}

// Serialize and cache
user := User{ID: 123, Name: "Alice", Email: "alice@example.com"}
data, err := cache.Marshal(user)
if err != nil {
    return err
}
err = m.cache.Set(ctx, "user:123", data, 5*time.Minute)

// Retrieve and deserialize
data, err := m.cache.Get(ctx, "user:123")
if err != nil {
    return err
}
user, err := cache.Unmarshal[User](data)
```

**Query Result Caching Pattern:**

```go
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first
    data, err := s.cache.Get(ctx, cacheKey)
    if err == nil {
        return cache.Unmarshal[User](data)
    }

    // Cache miss - query database
    user, err := s.queryDatabase(ctx, id)
    if err != nil {
        return nil, err
    }

    // Store in cache for future requests
    data, _ = cache.Marshal(user)
    s.cache.Set(ctx, cacheKey, data, 5*time.Minute)

    return user, nil
}
```

**Deduplication with GetOrSet:**

```go
// Atomic deduplication for idempotency keys
idempotencyKey := "process:batch:abc-123"
taskData := []byte("task-payload")

storedValue, wasSet, err := m.cache.GetOrSet(ctx, idempotencyKey, taskData, 10*time.Minute)
if err != nil {
    return err
}

if wasSet {
    // First time processing - execute task
    return processBatch(ctx, taskData)
}

// Duplicate request detected - return cached result
return getCachedResult(storedValue)
```

**Distributed Locking with CompareAndSet:**

```go
// Acquire distributed lock
lockKey := "lock:job:456"
workerID := []byte("worker-1")

success, err := m.cache.CompareAndSet(ctx, lockKey, nil, workerID, 30*time.Second)
if err != nil {
    return err
}

if !success {
    return errors.New("lock already held by another worker")
}

// Lock acquired - perform work
defer m.cache.Delete(ctx, lockKey) // Release lock

return processJob(ctx)
```

**Multi-Tenant Context Propagation:**

```go
import "github.com/gaborage/go-bricks/multitenant"

// HTTP handler - tenant resolved from request headers/hostname
func (h *Handler) GetUser(c echo.Context) error {
    ctx := c.Request().Context()  // Tenant already in context via middleware

    user, err := h.service.GetUser(ctx, userID)  // Uses tenant-specific cache
    return c.JSON(200, user)
}

// Testing multi-tenant cache isolation
func TestMultiTenantCacheIsolation(t *testing.T) {
    // Create mock caches for each tenant
    acmeCache := NewMockCache()
    globexCache := NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            tenantID := multitenant.GetTenant(ctx)
            switch tenantID {
            case "acme":
                return acmeCache, nil
            case "globex":
                return globexCache, nil
            default:
                return nil, errors.New("tenant not found")
            }
        },
    }

    svc := NewUserService(deps)

    // Test with acme tenant
    acmeCtx := multitenant.SetTenant(context.Background(), "acme")
    user1, _ := svc.GetUser(acmeCtx, 123)  // Uses acmeCache

    // Test with globex tenant
    globexCtx := multitenant.SetTenant(context.Background(), "globex")
    user2, _ := svc.GetUser(globexCtx, 123)  // Uses globexCache

    // Verify caches are isolated
    assert.NotEqual(t, user1, user2)  // Different tenant data
}
```

**Operation Reference:**

| Operation | Method | Use Case | Atomicity | Latency |
|-----------|--------|----------|-----------|---------|
| Basic read | Get(ctx, key) | Query result cache | Single-key | ~1ms |
| Basic write | Set(ctx, key, value, ttl) | Store computed result | Single-key | ~1ms |
| Remove | Delete(ctx, key) | Invalidation, lock release | Single-key | ~1ms |
| Deduplication | GetOrSet(ctx, key, value, ttl) | Idempotency keys | Atomic SET NX | ~2ms |
| Distributed lock | CompareAndSet(ctx, key, expected, new, ttl) | Job coordination | Lua script CAS | ~2ms |
| Type-safe store | Marshal(v) + Set() | Struct serialization | Single-key | ~1ms + encode |
| Type-safe retrieve | Get() + Unmarshal[T](data) | Struct deserialization | Single-key | ~1ms + decode |

**Error Handling & Graceful Degradation:**

```go
// Graceful degradation - cache failure doesn't break request
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first with timeout
    cacheCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    defer cancel()

    if cache, err := s.getCache(cacheCtx); err == nil {
        data, err := cache.Get(cacheCtx, cacheKey)
        if err == nil {
            user, err := cache.Unmarshal[User](data)
            if err == nil {
                return user, nil  // Cache hit - return immediately
            }
        }

        // Log cache errors but don't fail the request
        if !errors.Is(err, cache.ErrNotFound) {
            s.logger.Warn("Cache operation failed, falling back to database",
                "error", err, "key", cacheKey)
        }
    }

    // Always query database as fallback
    return s.queryDatabase(ctx, id)
}

// Timeout handling with context
ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
defer cancel()

data, err := cache.Get(ctx, key)
if errors.Is(err, context.DeadlineExceeded) {
    // Cache too slow - fallback to database
    s.logger.Warn("Cache timeout exceeded", "key", key)
}

// Error type checking
if errors.Is(err, cache.ErrNotFound) {
    // Key expired or never set - query database, repopulate cache
} else if errors.Is(err, cache.ErrClosed) {
    // Cache closed during shutdown - skip cache, continue request
} else if errors.Is(err, cache.ErrInvalidTTL) {
    // Developer error - negative or zero TTL provided
} else if opErr, ok := err.(*cache.OperationError); ok {
    // Network/Redis error - includes operation, key, underlying error
    s.logger.Error("Cache operation failed",
        "operation", opErr.Op,
        "key", opErr.Key,
        "error", opErr.Err)
}
```

**Common Error Scenarios:**

| Error | Cause | Recommended Handling |
|-------|-------|---------------------|
| `cache.ErrNotFound` | Key expired or never set | Query database, repopulate cache |
| `cache.ErrClosed` | Cache closed during shutdown | Skip cache, query database directly |
| `cache.ErrInvalidTTL` | Zero or negative TTL provided | Fix code - TTL must be positive |
| `cache.OperationError` | Network/Redis error | Log error, fallback to database |
| `context.DeadlineExceeded` | Operation timeout | Skip cache, continue with database |
| `config.NotConfiguredError` | Cache not enabled | Disable cache features gracefully |

**Health Checks & Monitoring:**

```go
// Cache health check (called by framework /health endpoint)
err := cache.Health(ctx)
if err != nil {
    // Redis: PING command failed
    // Cache unhealthy - alert operations team
}

// Framework automatically includes cache in health endpoint:
// GET /health
// {
//   "status": "healthy",
//   "checks": {
//     "database": "ok",
//     "cache": "ok",       // ← Automatic when cache enabled
//     "messaging": "ok"
//   }
// }

// Cache instance stats (Redis-specific)
stats, err := cache.Stats()
// {
//   "redis_info": {...},          // Redis SERVER INFO
//   "pool_hits": 12500,           // Connection pool hits
//   "pool_misses": 45,            // Connection pool misses
//   "pool_timeouts": 0,           // Pool timeout errors
//   "pool_total_conns": 10,       // Total connections
//   "pool_idle_conns": 7,         // Idle connections
//   "pool_stale_conns": 0         // Stale connections
// }

// CacheManager stats (multi-tenant lifecycle)
managerStats := cacheManager.Stats()
// {
//   "active_caches": 45,      // Current tenant caches
//   "total_created": 128,     // Lifetime cache instances
//   "evictions": 12,          // LRU evictions
//   "idle_cleanups": 71,      // Idle timeout cleanups
//   "errors": 0               // Creation/close errors
// }
```

**Observability Integration:**

When `observability.enabled: true` in config, cache operations automatically emit:

- **Traces:** Spans for Get/Set/Delete operations with `cache.operation`, `cache.key`, `cache.hit` attributes
- **Metrics:**
  - `cache.operation.duration{operation, status}` - Histogram of operation latency
  - `cache.errors.total{operation, error_type}` - Counter of cache errors
  - `cache.manager.active_caches` - Gauge of active tenant caches
- **Logs:** Structured logs with `cache_operation`, `key`, `duration_ms`, `tenant_id` fields

Example OpenTelemetry span:
```
Span: cache.get
  Attributes:
    cache.operation: "get"
    cache.key: "user:123"
    cache.hit: true
    cache.duration_ms: 1.2
    tenant.id: "acme"
```

No code changes required - observability hooks activate automatically when configured.

**Performance Characteristics:**

**Redis Cache Latency (localhost):**
- Get: ~0.5-1ms (single key, no network)
- Set: ~0.5-1ms (single key, no network)
- GetOrSet: ~1-2ms (Lua script execution)
- CompareAndSet: ~1-2ms (Lua script execution)

**Network Latency Impact:**
- Same datacenter: +0.5-1ms additional latency
- Cross-region: +50-200ms (NOT recommended for cache)

**Throughput (single Redis instance):**
- Reads: ~100,000 ops/sec
- Writes: ~80,000 ops/sec
- Mixed workload: ~90,000 ops/sec

**Connection Pool Sizing:**
```yaml
cache:
  redis:
    pool_size: 10  # Default: NumCPU * 2
```

**Rule:** `PoolSize >= (NumCPU * 2 * ConcurrentRequests) / 100`

Example: 8 CPUs, 500 concurrent requests → PoolSize = 80

**Cache vs Alternatives:**

| Scenario | Solution | Reason |
|----------|----------|--------|
| User sessions (shared across pods) | Redis Cache | Distributed state, automatic TTL |
| Query result cache (5min TTL) | Redis Cache | Built-in expiration, no manual cleanup |
| Application config (static) | In-memory `map` | No expiration needed, read-only |
| Rate limiting (per-tenant) | Redis Cache + `GetOrSet` | Atomic operations, distributed |
| Idempotency keys | Redis Cache + `CompareAndSet` | Distributed lock semantics |
| Local caching (per-pod) | `sync.Map` or `ristretto` | No network overhead, pod-local only |
| Distributed locks | Redis Cache + `CompareAndSet` | Cross-pod coordination |

**Cache vs Database Trade-offs:**

| Aspect | Cache (Redis) | Database (PostgreSQL/Oracle) |
|--------|---------------|------------------------------|
| **Durability** | Ephemeral (data loss on restart) | Durable (ACID guarantees) |
| **Latency** | <1ms (localhost) | 5-50ms (query complexity) |
| **Expiration** | Automatic TTL | Manual cleanup required |
| **Consistency** | Best-effort | Strong consistency |
| **Query Capability** | Key-value only | Complex SQL queries |
| **Use Case** | Read-heavy, acceptable staleness | Write-heavy, critical data |

**Rule:** Use cache for read-heavy workloads with acceptable data staleness (TTL-based invalidation).

**Cache Testing Utilities:**

**Note:** GoBricks does not yet provide a `cache/testing` package (similar to `database/testing`). Use interface mocking for now.

```go
import (
    "context"
    "sync"
    "time"

    "github.com/gaborage/go-bricks/cache"
)

// MockCache - Simple in-memory cache for testing
type MockCache struct {
    data map[string][]byte
    mu   sync.RWMutex
}

func NewMockCache() *MockCache {
    return &MockCache{data: make(map[string][]byte)}
}

func (m *MockCache) Get(_ context.Context, key string) ([]byte, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if val, ok := m.data[key]; ok {
        return val, nil
    }
    return nil, cache.ErrNotFound
}

func (m *MockCache) Set(_ context.Context, key string, value []byte, _ time.Duration) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = value
    return nil
}

func (m *MockCache) Delete(_ context.Context, key string) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    delete(m.data, key)
    return nil
}

func (m *MockCache) GetOrSet(_ context.Context, key string, value []byte, _ time.Duration) ([]byte, bool, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    if existing, ok := m.data[key]; ok {
        return existing, false, nil
    }
    m.data[key] = value
    return value, true, nil
}

func (m *MockCache) CompareAndSet(_ context.Context, key string, expected, new []byte, _ time.Duration) (bool, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    existing, exists := m.data[key]
    if expected == nil && !exists {
        m.data[key] = new
        return true, nil
    }
    if exists && string(existing) == string(expected) {
        m.data[key] = new
        return true, nil
    }
    return false, nil
}

func (m *MockCache) Health(_ context.Context) error {
    return nil
}

func (m *MockCache) Stats() (map[string]any, error) {
    return map[string]any{"entries": len(m.data)}, nil
}

func (m *MockCache) Close() error {
    return nil
}

// Test example with MockCache
func TestUserService_CacheHit(t *testing.T) {
    mockCache := NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
    }

    svc := NewUserService(deps)

    // Pre-populate cache
    user := &User{ID: 123, Name: "Alice"}
    data, _ := cache.Marshal(user)
    mockCache.Set(ctx, "user:123", data, 5*time.Minute)

    // Test cache hit
    result, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", result.Name)
}
```

## Cache Testing Utilities

GoBricks provides `cache/testing` package for easy cache mocking without Redis dependencies (**73% less boilerplate than manual mocks**).

**Mock Cache Setup:**

```go
import cachetest "github.com/gaborage/go-bricks/cache/testing"

func TestUserService(t *testing.T) {
    mockCache := cachetest.NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
    }

    svc := NewUserService(deps)
    user, err := svc.GetUser(ctx, 123)

    assert.NoError(t, err)
    assert.Equal(t, "Alice", user.Name)
}
```

**Configurable Behavior (Fluent API):**

```go
// Simulate cache failures
mockCache := cachetest.NewMockCache().
    WithGetFailure(cache.ErrConnectionError).
    WithDelay(100 * time.Millisecond)

// Service should gracefully degrade
user, err := svc.GetUser(ctx, 123)  // Falls back to database
assert.NoError(t, err)

// Verify operation counts
cachetest.AssertOperationCount(t, mockCache, "Get", 1)
```

**Available Assertion Helpers:**

```go
// Cache hit/miss assertions
cachetest.AssertCacheHit(t, mockCache, "user:123")
cachetest.AssertCacheMiss(t, mockCache, "missing:key")

// Operation counting
cachetest.AssertOperationCount(t, mockCache, "Get", 5)
cachetest.AssertOperationCountGreaterThan(t, mockCache, "Set", 10)

// Key existence (ignores expiration)
cachetest.AssertKeyExists(t, mockCache, "key1")
cachetest.AssertKeyNotExists(t, mockCache, "deleted:key")

// Cache state
cachetest.AssertCacheEmpty(t, mockCache)
cachetest.AssertCacheSize(t, mockCache, 3)
cachetest.AssertCacheClosed(t, mockCache)
cachetest.AssertCacheOpen(t, mockCache)

// Value assertions
cachetest.AssertValue(t, mockCache, "key1", []byte("expected-value"))
value := cachetest.AssertGetValue(t, mockCache, "key1")  // Returns value for further checks

// Error assertions
cachetest.AssertError(t, func() error {
    _, err := mockCache.Get(ctx, "key")
    return err
}, cache.ErrNotFound)

cachetest.AssertNoError(t, func() error {
    return mockCache.Set(ctx, "key", []byte("value"), time.Minute)
})
```

**Multi-Tenant Testing:**

```go
import (
    cachetest "github.com/gaborage/go-bricks/cache/testing"
    "github.com/gaborage/go-bricks/multitenant"
)

func TestMultiTenantCacheIsolation(t *testing.T) {
    tenantCaches := map[string]*cachetest.MockCache{
        "acme":   cachetest.NewMockCache(),
        "globex": cachetest.NewMockCache(),
    }

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            tenantID := multitenant.GetTenant(ctx)
            return tenantCaches[tenantID], nil
        },
    }

    svc := NewUserService(deps)

    // Test acme tenant
    acmeCtx := multitenant.SetTenant(context.Background(), "acme")
    user1, _ := svc.GetUser(acmeCtx, 123)

    // Test globex tenant
    globexCtx := multitenant.SetTenant(context.Background(), "globex")
    user2, _ := svc.GetUser(globexCtx, 123)

    // Verify isolation
    cachetest.AssertOperationCount(t, tenantCaches["acme"], "Get", 1)
    cachetest.AssertOperationCount(t, tenantCaches["globex"], "Get", 1)
}
```

**Advanced Configuration:**

```go
// Custom cache ID (useful for tracking multiple instances)
mock := cachetest.NewMockCacheWithID("test-cache-1")

// Failure injection for specific operations
mock := cachetest.NewMockCache().
    WithGetFailure(cache.ErrConnectionError).
    WithSetFailure(cache.ErrClosed).
    WithDeleteFailure(errors.New("custom error"))

// Simulate slow operations (timeout testing)
mock := cachetest.NewMockCache().WithDelay(500 * time.Millisecond)

ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
defer cancel()

_, err := mock.Get(ctx, "key")
assert.ErrorIs(t, err, context.DeadlineExceeded)

// Close callback (lifecycle tracking)
var closedCaches []string
mock := cachetest.NewMockCache().WithCloseCallback(func(id string) {
    closedCaches = append(closedCaches, id)
})
```

**Test Utilities:**

```go
// Reset between test cases
cachetest.ResetMock(mockCache)  // Clears data + counters

// Debugging
counts := cachetest.GetOperationCounts(mockCache)
fmt.Printf("Operations: %+v\n", counts)  // {Get:5, Set:3, Delete:1, ...}

dump := cachetest.DumpCache(mockCache)
t.Log(dump)  // Prints cache contents with expiration info

// Check all stored keys
keys := mockCache.GetAllKeys()
assert.Contains(t, keys, "user:123")

// Stats assertion
stats, _ := mockCache.Stats()
cachetest.AssertStatsContains(t, stats, "entry_count", 5)
```

**Testing Cache-Aside Pattern:**

```go
func TestCacheAsidePattern(t *testing.T) {
    mockCache := cachetest.NewMockCache()
    mockDB := dbtest.NewTestDB(dbtypes.PostgreSQL)

    mockDB.ExpectQuery("SELECT").WillReturnRows(
        dbtest.NewRowSet("id", "name").AddRow(int64(123), "Alice"),
    )

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return mockDB, nil
        },
    }

    svc := NewUserService(deps)
    ctx := context.Background()

    // First call - cache miss, loads from DB
    user1, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", user1.Name)

    // Verify cache miss then set
    cachetest.AssertOperationCount(t, mockCache, "Get", 1)
    cachetest.AssertOperationCount(t, mockCache, "Set", 1)
    dbtest.AssertQueryExecuted(t, mockDB, "SELECT")

    // Second call - cache hit, no DB query
    mockDB.ResetQueryLog()
    user2, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", user2.Name)

    // Verify cache hit
    cachetest.AssertOperationCount(t, mockCache, "Get", 2)
    cachetest.AssertOperationCount(t, mockCache, "Set", 1)  // Still 1
    assert.Empty(t, mockDB.GetQueryLog(), "Should not query DB on cache hit")
}
```

**Testing TTL Expiration:**

```go
func TestCacheTTLExpiration(t *testing.T) {
    mockCache := cachetest.NewMockCache()
    ctx := context.Background()

    // Set with short TTL
    mockCache.Set(ctx, "key1", []byte("value1"), 10*time.Millisecond)

    // Should exist immediately
    cachetest.AssertCacheHit(t, mockCache, "key1")

    // Wait for expiration
    time.Sleep(20 * time.Millisecond)

    // Should be expired
    cachetest.AssertCacheMiss(t, mockCache, "key1")
}
```

**Comparison with Manual Mocking:**

```go
// ❌ MANUAL MOCK (~150 lines of boilerplate)
type manualMockCache struct {
    data    map[string][]byte
    getCalls int
    setCalls int
    mu      sync.Mutex
}

func (m *manualMockCache) Get(ctx context.Context, key string) ([]byte, error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.getCalls++
    val, ok := m.data[key]
    if !ok {
        return nil, cache.ErrNotFound
    }
    return val, nil
}
// ... implement all 8 cache.Cache methods ...

// ✅ cache/testing MockCache (~5 lines)
mock := cachetest.NewMockCache()
// All methods implemented, thread-safe, operation tracking included
```

## Messaging Snapshot

```go
func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	exchange := decls.DeclareTopicExchange("orders.events")
	queue := decls.DeclareQueue("orders.processing")
	decls.DeclareBinding(queue.Name, exchange.Name, "order.*")

	decls.DeclarePublisher(&messaging.PublisherOptions{
		Exchange:   exchange.Name,
		RoutingKey: "order.created",
		EventType:  "OrderCreated",
	}, nil)

	// Default consumer (auto-scales to NumCPU*4 workers)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     queue.Name,
		Consumer:  "order-processor",
		EventType: "OrderCreated",
		Handler:   NewOrderHandler(m.svc, m.logger),
	}, nil)
	// 8-core machine: 32 workers, 320 prefetch

	// Sequential consumer (for ordering-sensitive processing)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     "account.events",
		Consumer:  "account-processor",
		EventType: "AccountUpdated",
		Workers:   1,  // Sequential processing
		Handler:   NewAccountHandler(m.svc, m.logger),
	}, nil)

	// High-concurrency consumer (for batch processing)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:         "reports.generate",
		Consumer:      "report-generator",
		EventType:     "ReportRequested",
		Workers:       50,           // High concurrency
		PrefetchCount: 500,          // Large prefetch
		Handler:       NewReportHandler(m.svc, m.logger),
	}, nil)
}
```

| Concern            | Built-in support                                  |
|--------------------|---------------------------------------------------|
| Idempotent setup   | Declarations validated once, replayed per tenant  |
| Error handling     | **No automatic retry** - all errors drop message (prevents infinite loops). Rich ERROR logs + metrics for failed messages. DLQ support planned. |
| **Concurrency (v0.17+)** | **Auto-scales to NumCPU*4 workers** for I/O-bound handlers. Override with `Workers` field. Sequential (`Workers=1`) for ordering. |
| Publishers         | Typed options ensure routing key + event type     |
| Consumers          | Handler receives `context.Context`, `amqp.Delivery`; return error drops message |
| Metrics & tracing  | Automatic OTEL spans + structured logs            |

Use `messaging.Client.Publish(ctx, routingKey, payload)` for runtime sends.

**IMPORTANT:**
- Handler errors do NOT trigger retry. Failed messages are logged (ERROR level) with full context and dropped.
- **v0.17+**: Handlers MUST be thread-safe (auto-scales to NumCPU*4 workers). Test with `go test -race`.
- Database pools must be sized: `MaxOpenConns >= NumCPU * 4 * NumConsumers`

## Multi-Tenancy
- Enable with `multitenant.enabled=true`.
- Resolution strategies: `header`, `host`, or custom store implementing `multitenant.Store`.
- Each tenant gets isolated DB connections, messaging clients, and module lifecycle events.

```yaml
multitenant:
  enabled: true
  tenant_resolution:
    strategy: header
    header_name: X-Tenant-ID
```

## Observability & Logging

```yaml
observability:
  enabled: true
  service_name: my-service
  trace: { enabled: true, endpoint: "http://otel-collector:4318", protocol: http }
  metrics: { enabled: true }
  logs:
    enabled: true
    slow_request_threshold: 750ms

logger:
  pretty: false # set false when exporting to OTLP
  level: info
```

Set `GOBRICKS_DEBUG=true` to emit `[OBSERVABILITY]` diagnostics during local runs.

## Common Patterns
- **Error handling**: wrap service errors with `server.InternalServerError`; map domain errors to `server.NotFound`, `server.Unauthorized`, etc.
- **Graceful shutdown**: close external resources in `Module.Shutdown`; the framework waits on outstanding requests.
- **Configuration injection**: `deps.Config.InjectInto(&cfgStruct)` honors defaults and env overrides.
- **Testing**: `obtest.NewTestTraceProvider()` captures spans/logs; mock `database.Interface` and `messaging.Client` directly.
