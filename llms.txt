# GoBricks Framework

Enterprise Go microservice toolkit (Go 1.24+). Provides multi-database access, typed HTTP handlers, AMQP messaging, tenant isolation, and built-in OpenTelemetry.

## Quick Start
- `go get github.com/gaborage/go-bricks`
- Scaffold:

```go
package main

import (
	"log"

	"github.com/gaborage/go-bricks/app"
	"github.com/gaborage/go-bricks/config"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}

	// Framework auto-initializes when observability.enabled: true in config:
	// - Distributed tracing (OpenTelemetry spans)
	// - Metrics (HTTP, database, messaging)
	// - Structured logging with trace correlation
	// - HTTP request auto-instrumentation
	fw, err := app.NewWithConfig(cfg, nil)
	if err != nil {
		log.Fatal(err)
	}

	fw.RegisterModules(/* modules */)

	// Graceful shutdown: flushes pending spans/metrics before exit
	log.Fatal(fw.Run())
}
```

## Config Snapshot

```yaml
app:
  name: my-service
  environment: development
server:
  enabled: true
  port: 8080
database:
  type: postgres # postgres | oracle | mongo
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
logger:
  level: info
  pretty: true
```

`Highest precedence first: env vars > config.<env>.yaml > config.yaml > struct defaults.`
Add observability settings as needed (see Observability & Logging).

## Core Concepts
- Framework injects dependencies via `*app.ModuleDeps`; avoid constructing raw `*sql.DB`.
- Declarative messaging defines exchanges, queues, bindings, publishers, and consumers once; the framework replays per tenant.
- Observability hooks (traces, metrics, structured logs) activate when `observability.enabled=true`.
- Multi-tenant mode resolves tenants (header/host/custom store) and hands each module tenant-specific resources.

## Module Skeleton

```go
type Module struct {
	// Function-based injection: works for both single-tenant AND multi-tenant
	getDB  func(context.Context) (database.Interface, error)
	logger logger.Logger
}

func (m *Module) Name() string { return "mymodule" }

func (m *Module) Init(deps *app.ModuleDeps) error {
	// Store function reference, NOT database instance
	// In multi-tenant mode, database is resolved per-request from tenant context
	m.getDB = deps.DB
	m.logger = deps.Logger.WithFields(map[string]any{"module": m.Name()})
	return nil
}

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, e *echo.Echo) {
	handler := NewHandler(m.getDB, m.logger)
	server.POST(hr, e, "/users", handler.Create)
}

func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	// optional
}

func (m *Module) Shutdown() error { return nil }
```

## Typed HTTP Handlers

```go
type CreateUserReq struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required,email"`
}

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (h *Handler) Create(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	reqCtx := ctx.Request().Context()
	user, err := h.svc.Create(reqCtx, req)
	if err != nil {
		return server.Result[User]{}, server.InternalServerError(err)
	}
	return server.Created(user), nil
}

// === Simple HTTP GET Endpoints ===

// Static message endpoint (simplest possible handler)
func (h *Handler) Health(_ server.NoBody, ctx server.HandlerContext) (server.Result[string], server.IAPIError) {
	return server.OK("Service is healthy"), nil
}

// Register: server.GET(hr, e, "/health", h.Health)

// GET with path parameter
type GetUserReq struct {
	ID string `param:"id" validate:"required,uuid"`
}

func (h *Handler) GetUser(req GetUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	user, err := h.svc.FindByID(ctx.Request().Context(), req.ID)
	if err != nil {
		return server.Result[User]{}, server.NotFound(errors.New("user not found"))
	}
	return server.OK(user), nil
}

// Register: server.GET(hr, e, "/users/:id", h.GetUser)

// GET with query parameters
type ListUsersReq struct {
	Status string `query:"status" validate:"omitempty,oneof=active inactive"`
	Limit  int    `query:"limit" validate:"omitempty,min=1,max=100"`
}

func (h *Handler) ListUsers(req ListUsersReq, ctx server.HandlerContext) (server.Result[[]User], server.IAPIError) {
	limit := req.Limit
	if limit == 0 {
		limit = 20 // Default
	}
	users, err := h.svc.List(ctx.Request().Context(), req.Status, limit)
	if err != nil {
		return server.Result[[]User]{}, server.InternalServerError(err)
	}
	return server.OK(users), nil
}

// Register: server.GET(hr, e, "/users", h.ListUsers)
// Usage: GET /users?status=active&limit=50
```

| Pattern          | Request binding              | Success helper          | Notes                          |
|------------------|------------------------------|-------------------------|--------------------------------|
| POST create      | JSON struct w/ validators    | `server.Created(data)`  | 422 auto-emitted on validation |
| GET lookup       | `server.NoBody` + `ctx.Param`| `server.OK(data)`       | Return domain errors as API    |
| LIST with query  | `query:"..."` struct tags    | `server.OK(list)`       | Query params auto-bound        |
| DELETE           | `server.NoBody`              | `server.NoContent()`    | Return typed API errors        |
| ASYNC acceptance | Request struct               | `server.Accepted(meta)` | For enqueue-style workflows    |

### Pointer Types for Large Payloads

Use **pointer types** for requests/responses >1KB to eliminate copy overhead. Fully backward compatible.

```go
// Large request - file upload (pointer avoids copying MB of data)
type FileUploadRequest struct {
	Data     []byte `json:"data" validate:"required"` // Base64-encoded file
	Filename string `json:"filename" validate:"required"`
	MimeType string `json:"mime_type"`
}

func (h *Handler) UploadFile(req *FileUploadRequest, ctx server.HandlerContext) (server.Result[UploadResponse], server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	fileID, err := h.storageService.Store(reqCtx, req.Data, req.Filename, req.MimeType)
	if err != nil {
		return server.Result[UploadResponse]{}, server.InternalServerError(err)
	}
	return server.Created(UploadResponse{FileID: fileID, Size: len(req.Data)}), nil
}

// Large response - bulk export (pointer avoids copying thousands of records)
type BulkExportResponse struct {
	Records []Record `json:"records"`
	Total   int      `json:"total"`
	Page    int      `json:"page"`
}

func (h *Handler) ExportRecords(req ExportRequest, ctx server.HandlerContext) (*BulkExportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	records, err := h.recordService.GetAll(reqCtx, req.Filter)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkExportResponse{
		Records: records,
		Total:   len(records),
		Page:    req.Page,
	}, nil
}

// Both pointer types - bulk import handler
type BulkImportRequest struct {
	Records []ImportRecord `json:"records" validate:"required,min=1,max=10000"`
	DryRun  bool           `json:"dry_run"`
}

type BulkImportResponse struct {
	Imported int      `json:"imported"`
	Failed   int      `json:"failed"`
	Errors   []string `json:"errors,omitempty"`
}

func (h *Handler) BulkImport(req *BulkImportRequest, ctx server.HandlerContext) (*BulkImportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	result, err := h.importService.ProcessBulk(reqCtx, req.Records, req.DryRun)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkImportResponse{
		Imported: result.Imported,
		Failed:   result.Failed,
		Errors:   result.Errors,
	}, nil
}
```

**Performance guidelines:**
- **<1KB**: Use value types (default, idiomatic Go)
- **1KB-10KB**: Consider pointers for high-traffic endpoints
- **>10KB**: Always use pointers (file uploads, bulk operations)
- Pointer fields (`*string`, `*int`) work correctly with validation (`omitempty`, `min=`)

## HTTP Middleware

```go
// === Custom Middleware Function Structure ===
// Middleware wraps handlers to perform pre/post processing

import (
	"context"

	"github.com/labstack/echo/v4"
	"github.com/gaborage/go-bricks/server"
	"github.com/gaborage/go-bricks/multitenant"
)

// Authentication middleware - validates token and injects user into context
func AuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		token := c.Request().Header.Get("Authorization")
		if token == "" {
			return server.NewUnauthorizedError("missing authorization header")
		}

		// Validate token (your auth logic here)
		userID, err := validateToken(token)
		if err != nil {
			return server.NewUnauthorizedError("invalid token")
		}

		// Add user to context for downstream handlers
		ctx := context.WithValue(c.Request().Context(), "user_id", userID)
		c.SetRequest(c.Request().WithContext(ctx))
		return next(c)
	}
}

// Logging middleware - logs request details
func LoggingMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		start := time.Now()
		err := next(c)
		duration := time.Since(start)

		logger.Info().
			Str("method", c.Request().Method).
			Str("path", c.Request().URL.Path).
			Int("status", c.Response().Status).
			Dur("duration", duration).
			Msg("Request completed")

		return err
	}
}

// === Register Middleware in Module ===

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, r server.RouteRegistrar) {
	// Global middleware for all routes in this module
	r.Use(LoggingMiddleware)

	// Group with auth middleware - all routes inherit it
	admin := r.Group("/admin", AuthMiddleware)
	server.GET(hr, admin, "/users", m.listUsers)
	server.POST(hr, admin, "/users", m.createUser)
	server.DELETE(hr, admin, "/users/:id", m.deleteUser)

	// Public routes (no auth middleware)
	server.GET(hr, r, "/health", m.healthCheck)
	server.GET(hr, r, "/version", m.version)
}

// === Middleware with Skipper (Conditional Execution) ===

// RateLimitWithSkipper - skips rate limiting for health probes
func RateLimitWithSkipper(rps int, skipper func(echo.Context) bool) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			if skipper != nil && skipper(c) {
				return next(c) // Skip rate limiting
			}
			// Apply rate limiting logic here
			return next(c)
		}
	}
}

// Common skipper - skip health and ready probes
func healthSkipper(c echo.Context) bool {
	path := c.Request().URL.Path
	return path == "/health" || path == "/ready"
}

// === Context Propagation Pattern (Tenant/User Injection) ===

// TenantMiddleware - extracts tenant from header and injects into context
func TenantMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		tenantID := c.Request().Header.Get("X-Tenant-ID")
		if tenantID == "" {
			return server.NewBadRequestError("X-Tenant-ID header required")
		}

		// Inject tenant into context - available to all downstream code
		ctx := multitenant.SetTenant(c.Request().Context(), tenantID)
		c.SetRequest(c.Request().WithContext(ctx))
		return next(c)
	}
}

// Access tenant in handler
func (h *Handler) GetUser(req GetUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	tenantID := multitenant.GetTenant(ctx.Request().Context())
	// tenantID is now available for tenant-specific logic
	user, err := h.svc.GetUserForTenant(ctx.Request().Context(), tenantID, req.ID)
	// ...
}
```

| Pattern | Use Case | Example |
|---------|----------|---------|
| `r.Use(middleware)` | Apply to all routes in group | Logging, metrics |
| `r.Group("/path", middleware)` | Apply to route subtree | Auth for /admin/* |
| Skipper function | Conditionally skip | Skip rate limit for /health |
| Context propagation | Pass data downstream | User ID, tenant ID |

## Database Builder & Operations

```go
// Define entity with db tags
type User struct {
    ID     int64  `db:"id"`
    Email  string `db:"email"`
    Status string `db:"status"`
}

qb := builder.NewQueryBuilder(m.db.DatabaseType())
f := qb.Filter()
cols := qb.Columns(&User{})

sql, args := qb.Select(cols.Fields("ID", "Email")...).
	From("users").
	Where(f.And(
		f.Eq(cols.Col("Status"), "active"),
		f.Like(cols.Col("Email"), "%@example.com"),
	)).
	ToSQL()

ctx := context.Background() // or propagate incoming request context
rows, err := m.db.Query(ctx, sql, args...)
```

| Need                | Builder call / API usage                                               |
|---------------------|------------------------------------------------------------------------|
| Filtering           | `f.Eq`, `f.And`, `f.Or`, `f.In`, `f.Between`                           |
| Sorting / grouping  | `qb.Select(...).From("...").OrderBy(qb.Expr("created_at DESC")).GroupBy("tenant_id")` |
| Mutations           | `qb.Insert`, `qb.Update`, `qb.Delete`, then `db.Exec`                  |
| Joins               | `qb.JoinOn` with `qb.JoinFilter()`                                     |
| Subqueries          | Compose another builder clause then `f.Exists(subQuery)`               |
| Transactions        | `tx, err := db.Begin(ctx); if err != nil { return err }; defer tx.Rollback(ctx); /* work */; if err := tx.Commit(ctx); err != nil { return err }` |

**Mutation Examples (INSERT/UPDATE/DELETE):**

```go
// INSERT
sql, args := qb.Insert("users").
    Columns(cols.Col("Name"), cols.Col("Email")).
    Values("Alice", "alice@example.com").
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// UPDATE
sql, args := qb.Update("users").
    Set(cols.Col("Name"), "Bob").
    Set(cols.Col("Email"), "bob@example.com").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// DELETE
sql, args := qb.Delete("users").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)
```

Access to vendor quirks (Oracle quoting, Mongo builders) routes through the same interface; switching drivers requires config only.

**Struct-Based Columns (v0.15.0+):**

```go
// Define entity once with db tags
type User struct {
    ID    int64  `db:"id"`
    Name  string `db:"name"`
    Level int    `db:"level"` // Oracle reserved word - auto-quoted
}

// Extract columns (cached per vendor)
cols := qb.Columns(&User{})

// SELECT with type-safe field references
query := qb.Select(cols.Fields("ID", "Name")...).
    From("users").
    Where(f.Eq(cols.Col("Level"), 5))
// Oracle: SELECT "ID", "NAME" FROM users WHERE "LEVEL" = :1
// PostgreSQL: SELECT id, name FROM users WHERE level = $1

// All columns: cols.All()
// Single column: cols.Col("FieldName")
// Multiple columns: cols.Fields("ID", "Name", "Email")
// Performance: ~0.6µs first parse, ~26ns cached access
```

**Table Aliases with Struct-Based Columns:**

```go
type User struct {
    ID     int64  `db:"id"`
    Name   string `db:"name"`
    Status string `db:"status"`
}

type Account struct {
    ID     int64  `db:"id"`
    Number string `db:"number"` // Oracle reserved word - auto-quoted
}

userCols := qb.Columns(&User{})
acctCols := qb.Columns(&Account{})

// Create aliased instances using As()
u := userCols.As("u")
a := acctCols.As("a")

jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select(
    u.Col("ID"),      // "u.id" or "u.\"ID\"" for Oracle
    u.Col("Name"),    // "u.name" or "u.\"NAME\"" for Oracle
    a.Col("Number"),  // "a.\"NUMBER\"" for Oracle (reserved word)
).
    From(dbtypes.Table("users").As("u")).
    JoinOn(dbtypes.Table("accounts").As("a"),
        jf.EqColumn(u.Col("ID"), a.Col("ID"))).
    Where(f.Eq(u.Col("Status"), "active"))
// Oracle: SELECT u."ID", u."NAME", a."NUMBER" FROM users u JOIN accounts a ON u."ID" = a."ID" WHERE u."STATUS" = :1
```

**Advanced JOIN Patterns:**

```go
// Mixed JOIN conditions: column-to-column + column-to-value with expressions
jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select("*").
    From(dbtypes.Table("orders").As("o")).
    JoinOn(dbtypes.Table("customers").As("c"), jf.And(
        jf.EqColumn("c.id", "o.customer_id"),       // Column-to-column
        jf.Eq("c.status", "active"),                 // Column-to-value
        jf.In("c.tier", []string{"gold", "platinum"}),
    )).
    JoinOn(dbtypes.Table("products").As("p"), jf.And(
        jf.EqColumn("p.id", "o.product_id"),
        jf.Eq("p.price", qb.Expr("TO_NUMBER(o.max_price)")), // Expression support
    )).
    Where(f.Eq("o.status", "pending"))
```

**Window Functions & Aggregations:**

```go
type Product struct {
    ProductID int64   `db:"product_id"`
    Price     float64 `db:"price"`
    Category  string  `db:"category"`
}
cols := qb.Columns(&Product{})

// Window function with PARTITION BY
query := qb.Select(
    cols.Col("ProductID"),
    cols.Col("Price"),
    qb.Expr("ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC)", "rank"),
).From("products")

// Aggregations with GROUP BY
query := qb.Select(
    cols.Col("Category"),
    qb.Expr("COUNT(*)", "product_count"),
    qb.Expr("AVG(price)", "avg_price"),
).From("products").GroupBy(cols.Col("Category"))
```

## Oracle SEQUENCE vs UDT - Important Distinction

### Oracle SEQUENCE Objects (ID Generation)

**SEQUENCE queries work immediately - NO UDT registration required:**

```go
// Get next ID from sequence
var nextID int64
err := conn.QueryRow(ctx, "SELECT SEQ_ID_TABLE.NEXTVAL FROM DUAL").Scan(&nextID)

// Get current sequence value
var currID int64
err := conn.QueryRow(ctx, "SELECT SEQ_ID_TABLE.CURRVAL FROM DUAL").Scan(&currID)

// Use in INSERT statement
_, err = conn.Exec(ctx, "INSERT INTO users (id, name) VALUES (user_seq.NEXTVAL, :1)", name)
```

**Creating sequences in Oracle:**
```sql
CREATE SEQUENCE user_seq START WITH 1000 INCREMENT BY 1;
CREATE SEQUENCE order_seq START WITH 10000 INCREMENT BY 10;
```

### Oracle User-Defined Types (Custom Objects/Collections)

**UDT registration ONLY required for custom types created with CREATE TYPE:**

```go
import "github.com/gaborage/go-bricks/database/oracle"

// 1. Define struct matching Oracle object type
type Product struct {
    ID    int64   `udt:"ID"`       // Must match Oracle field names
    Name  string  `udt:"NAME"`
    Price float64 `udt:"PRICE"`
}

// 2. Type assert to access Oracle-specific methods
oracleConn := conn.(*oracle.Connection)

// 3. Register collection type for bulk operations
err := oracleConn.RegisterType("PRODUCT_TYPE", "PRODUCT_TABLE", Product{})
if err != nil {
    return fmt.Errorf("UDT registration failed: %w", err)
}

// 4. Use in bulk insert
products := []Product{
    {ID: 1, Name: "Widget", Price: 19.99},
    {ID: 2, Name: "Gadget", Price: 29.99},
}

_, err = conn.Exec(ctx, "BEGIN bulk_insert_products(:1); END;", products)
```

**Oracle type definitions:**
```sql
-- Object type
CREATE TYPE PRODUCT_TYPE AS OBJECT (
    ID    NUMBER,
    NAME  VARCHAR2(100),
    PRICE NUMBER(10,2)
);

-- Collection type (TABLE OF = unbounded array)
CREATE TYPE PRODUCT_TABLE AS TABLE OF PRODUCT_TYPE;

-- Stored procedure accepting collection
CREATE OR REPLACE PROCEDURE bulk_insert_products(p_products IN PRODUCT_TABLE) IS
BEGIN
    FORALL i IN INDICES OF p_products
        INSERT INTO products (id, name, price)
        VALUES (p_products(i).ID, p_products(i).NAME, p_products(i).PRICE);
END;
```

### Schema-Qualified UDTs

```go
type Customer struct {
    CustomerID int    `udt:"CUSTOMER_ID"`
    Name       string `udt:"NAME"`
}

oracleConn := conn.(*oracle.Connection)

// Register from specific schema
err := oracleConn.RegisterTypeWithOwner("SHARED_SCHEMA", "CUSTOMER_TYPE", "CUSTOMER_TABLE", Customer{})

customers := []Customer{{CustomerID: 1, Name: "ACME"}, ...}
_, err = conn.Exec(ctx, "BEGIN SHARED_SCHEMA.process_customers(:1); END;", customers)
```

### VARRAY (Bounded Arrays)

For fixed-size arrays:

```sql
-- Oracle: Create bounded array type
CREATE TYPE STATUS_CODES AS VARRAY(10) OF VARCHAR2(20);
```

```go
type StatusCode struct {
    Code string `udt:"CODE"`
}

oracleConn.RegisterType("STATUS_CODE", "STATUS_CODES", StatusCode{})

// Use with bounded array
codes := []StatusCode{
    {Code: "PENDING"},
    {Code: "APPROVED"},
    {Code: "COMPLETED"},
}
```

### Single Object Types (No Collections)

If you only need single object parameters (not arrays):

```go
type Customer struct {
    ID   int    `udt:"ID"`
    Name string `udt:"NAME"`
}

// Register without collection type (arrayTypeName = "")
err := oracleConn.RegisterType("CUSTOMER_TYPE", "", Customer{})

// Use single object in procedure
customer := Customer{ID: 123, Name: "ACME Corp"}
_, err = conn.Exec(ctx, "BEGIN update_customer(:1); END;", customer)
```

### Common Errors

**Error:** `"call register type before use user defined type (UDT)"`
**Cause:** Trying to use custom TYPE in stored procedure without RegisterType()
**Solution:** Call RegisterType() during initialization before using UDT

**Important:** This error does NOT affect SEQUENCE queries - sequences always work without registration

### Key Takeaways

- **SEQUENCE objects** (auto-increment IDs) → No registration needed, standard SQL queries
- **UDT collection types** (TABLE OF, VARRAY) → Requires RegisterType() before use
- **Type assertion required** → Must cast to `*oracle.Connection` to access UDT methods
- **Registration timing** → Call during application initialization, before any UDT queries
- **Tag format** → `udt:` tags must EXACTLY match Oracle field names (case-sensitive, usually uppercase)

## Database Testing

> **⚠️ IMPORTANT RESOURCE MANAGEMENT:**
> When using `Query()` or `TestTx.Query()`, **ALWAYS call `defer rows.Close()`** immediately after obtaining rows.
> The returned `*sql.Rows` is backed by a temporary `*sql.DB` that must be explicitly closed to prevent resource leaks.
> A finalizer provides a safety net, but **explicit cleanup via `defer` is mandatory** for deterministic resource management.

**Simple Query Test:**

```go
import dbtest "github.com/gaborage/go-bricks/database/testing"

func TestProductService_FindActive(t *testing.T) {
    // Setup (8 lines vs 30+ with sqlmock)
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewProductService(deps)
    products, err := svc.FindActive(ctx)

    assert.NoError(t, err)
    assert.Len(t, products, 2)
dbtest.AssertQueryExecuted(t, db, "SELECT")
}
```

**Iterating Rows with `Query`:**

```go
func TestProductRepository_List(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    rows, err := db.Query(context.Background(), "SELECT id, name FROM products")
    require.NoError(t, err)
    defer rows.Close()

    var got []Product
    for rows.Next() {
        var p Product
        require.NoError(t, rows.Scan(&p.ID, &p.Name))
        got = append(got, p)
    }

    require.NoError(t, rows.Err())
    assert.Len(t, got, 2)
}
```

**Transaction Test:**

```go
func TestOrderService_CreateWithItems(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    tx := db.ExpectTransaction().
        ExpectExec("INSERT INTO orders").WillReturnRowsAffected(1).
        ExpectExec("INSERT INTO items").WillReturnRowsAffected(3)

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewOrderService(deps)
    err := svc.CreateWithItems(ctx, order, items)

    assert.NoError(t, err)
    dbtest.AssertCommitted(t, tx)
}
```

**Multi-Tenant Test:**

```go
func TestMultiTenantService(t *testing.T) {
    tenants := dbtest.NewTenantDBMap()

    // Setup tenant-specific expectations
    tenants.ForTenant("acme").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(1)),
        )
    tenants.ForTenant("globex").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(2)),
        )

    deps := &app.ModuleDeps{
        GetDB: tenants.AsGetDBFunc(),  // Resolves tenant from ctx
    }

    // Test with tenant context
    ctx := multitenant.SetTenant(context.Background(), "acme")
    result, err := svc.Process(ctx)

    assert.NoError(t, err)
    dbtest.AssertQueryExecuted(t, tenants.TenantDB("acme"), "SELECT")
}
```

**Named Databases Test (Single-Tenant Multi-Database):**

```go
func TestCrossDatabase_LegacyMigration(t *testing.T) {
    namedDBs := dbtest.NewNamedDBMap()

    // Setup default PostgreSQL database
    defaultDB := dbtest.NewTestDB(dbtypes.PostgreSQL)
    defaultDB.ExpectExec("INSERT INTO users").WillReturnRowsAffected(1)
    namedDBs.SetDefaultDB(defaultDB)

    // Setup legacy Oracle database
    namedDBs.ForNameWithVendor("legacy", dbtypes.Oracle).
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id", "name").AddRow(int64(1), "LegacyUser"),
        )

    // Setup analytics PostgreSQL database
    namedDBs.ForName("analytics").
        ExpectExec("INSERT INTO events").WillReturnRowsAffected(1)

    deps := &app.ModuleDeps{
        DB:       namedDBs.AsDBFunc(),       // Default database
        DBByName: namedDBs.AsDBByNameFunc(), // Named databases
    }

    svc := NewMigrationService(deps)
    err := svc.MigrateLegacyUser(context.Background(), 1)

    assert.NoError(t, err)
    dbtest.AssertQueryExecuted(t, namedDBs.NamedDB("legacy"), "SELECT")
    dbtest.AssertExecExecuted(t, namedDBs.DefaultDB(), "INSERT INTO users")
    dbtest.AssertExecExecuted(t, namedDBs.NamedDB("analytics"), "INSERT INTO events")
}
```

**RowSet Builders:**

```go
// From structs with db tags
type User struct {
    ID   int64  `db:"id"`
    Name string `db:"name"`
}

rows := dbtest.NewRowSet("id", "name").
    AddRowsFromStructs(
        &User{ID: 1, Name: "Alice"},
        &User{ID: 2, Name: "Bob"},
    )

// With generator function
rows := dbtest.NewRowSet("id", "name").
    AddRows(100, func(i int) []any {
        return []any{int64(i+1), fmt.Sprintf("User%d", i+1)}
    })

// RowSet powers both Query() and QueryRow() expectations. It now materializes
// real *sql.Rows under the hood, so you can iterate using database/sql's
// standard pattern. Supported value types include integers, floats, bools,
// strings, []byte, time.Time, fmt.Stringer, and nil.
```

**Assertion Helpers:**

```go
dbtest.AssertQueryExecuted(t, db, "SELECT")
dbtest.AssertQueryCount(t, db, "SELECT", 2)
dbtest.AssertExecExecuted(t, db, "INSERT")
dbtest.AssertTransactionCommitted(t, db)
dbtest.AssertTransactionRolledBack(t, db)
```

See [database/testing](database/testing/) package for full API documentation.

## Cache Operations (Redis)

**Configuration:**

```yaml
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
    password: ${CACHE_REDIS_PASSWORD} # from env
    database: 0
    pool_size: 10
```

**CacheManager Lifecycle (Multi-Tenant Applications):**

GoBricks uses CacheManager to handle per-tenant cache instances with automatic lifecycle management:

- **Lazy Initialization:** Cache created on first access per tenant (no upfront connections)
- **LRU Eviction:** Oldest cache evicted when MaxSize exceeded (default: 100 tenants)
- **Idle Cleanup:** Unused caches closed after IdleTTL (default: 15m, checked every 5m)
- **Singleflight:** Prevents duplicate cache creation during concurrent access

```yaml
# Optional: Override CacheManager defaults
cache:
  enabled: true
  manager:
    max_size: 100          # Max tenant cache instances
    idle_ttl: 15m          # Idle timeout per cache
    cleanup_interval: 5m   # Cleanup goroutine frequency
  redis:
    host: localhost
    port: 6379
```

**Manager Statistics:**

```go
// Access manager stats (useful for monitoring)
stats := cacheManager.Stats()  // From app internals

// ManagerStats{
//   ActiveCaches:  45,      // Current active instances
//   TotalCreated:  128,     // Lifetime total
//   Evictions:     12,      // LRU evictions
//   IdleCleanups:  71,      // Timeout cleanups
//   Errors:        0,       // Creation/close errors
//   MaxSize:       100,
//   IdleTTL:       900      // seconds
// }
```

**Module Setup (Multi-Tenant Aware):**

```go
import (
    "context"
    "fmt"
    "time"

    "github.com/gaborage/go-bricks/app"
    "github.com/gaborage/go-bricks/cache"
)

// IMPORTANT: Store GetCache function, NOT cache instance
type Module struct {
    getCache func(context.Context) (cache.Cache, error)
    logger   logger.Logger
}

func (m *Module) Init(deps *app.ModuleDeps) error {
    m.getCache = deps.GetCache  // Store function for tenant-aware resolution
    m.logger = deps.Logger
    return nil
}

// Service method using tenant context
type UserService struct {
    getCache func(context.Context) (cache.Cache, error)
}

func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    // GetCache resolves tenant from context automatically
    cache, err := s.getCache(ctx)
    if err != nil {
        return nil, fmt.Errorf("cache not available: %w", err)
    }

    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first
    data, err := cache.Get(ctx, cacheKey)
    if err == nil {
        return cache.Unmarshal[User](data)
    }

    // Cache miss - query database
    user, err := s.queryDatabase(ctx, id)
    if err != nil {
        return nil, err
    }

    // Store in cache
    serialized, _ := cache.Marshal(user)
    cache.Set(ctx, cacheKey, serialized, 5*time.Minute)

    return user, nil
}
```

**Basic Cache Operations:**

```go
// Set with TTL
err := cache.Set(ctx, "user:123", []byte("data"), 5*time.Minute)

// Get
data, err := cache.Get(ctx, "user:123")
if errors.Is(err, cache.ErrNotFound) {
    // Key doesn't exist - fetch from database
}

// Delete
err := cache.Delete(ctx, "user:123")
```

**Custom Cache Configuration Injection:**

```go
import "github.com/gaborage/go-bricks/config"

// Module-specific cache configuration
type CacheConfig struct {
    DefaultTTL time.Duration `config:"custom.cache.default_ttl" default:"5m"`
    KeyPrefix  string        `config:"custom.cache.key_prefix" default:"myapp"`
    MaxRetries int           `config:"custom.cache.max_retries" default:"3"`
}

type Module struct {
    getCache   func(context.Context) (cache.Cache, error)
    defaultTTL time.Duration
    keyPrefix  string
}

func (m *Module) Init(deps *app.ModuleDeps) error {
    // Inject custom cache config from YAML
    var cacheCfg CacheConfig
    if err := deps.Config.InjectInto(&cacheCfg); err != nil {
        return fmt.Errorf("cache config injection failed: %w", err)
    }

    m.getCache = deps.GetCache
    m.defaultTTL = cacheCfg.DefaultTTL
    m.keyPrefix = cacheCfg.KeyPrefix

    deps.Logger.Info("Cache configured",
        "default_ttl", m.defaultTTL,
        "key_prefix", m.keyPrefix)

    return nil
}

// Use injected config in service methods
func (m *Module) CacheUser(ctx context.Context, user *User) error {
    cache, _ := m.getCache(ctx)

    key := fmt.Sprintf("%s:user:%d", m.keyPrefix, user.ID)  // Uses prefix
    data, _ := cache.Marshal(user)

    return cache.Set(ctx, key, data, m.defaultTTL)  // Uses default TTL
}
```

**Configuration (config.yaml):**
```yaml
custom:
  cache:
    default_ttl: 10m      # Override module default
    key_prefix: myservice
    max_retries: 5
```

**Type-Safe Serialization:**

```go
import "github.com/gaborage/go-bricks/cache"

type User struct {
    ID    int64  `cbor:"1,keyasint"` // Optimized: integer keys
    Name  string `cbor:"2,keyasint"`
    Email string `cbor:"3,keyasint"`
}

// Serialize and cache
user := User{ID: 123, Name: "Alice", Email: "alice@example.com"}
data, err := cache.Marshal(user)
if err != nil {
    return err
}
err = m.cache.Set(ctx, "user:123", data, 5*time.Minute)

// Retrieve and deserialize
data, err := m.cache.Get(ctx, "user:123")
if err != nil {
    return err
}
user, err := cache.Unmarshal[User](data)
```

**Query Result Caching Pattern:**

```go
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first
    data, err := s.cache.Get(ctx, cacheKey)
    if err == nil {
        return cache.Unmarshal[User](data)
    }

    // Cache miss - query database
    user, err := s.queryDatabase(ctx, id)
    if err != nil {
        return nil, err
    }

    // Store in cache for future requests
    data, _ = cache.Marshal(user)
    s.cache.Set(ctx, cacheKey, data, 5*time.Minute)

    return user, nil
}
```

**Deduplication with GetOrSet:**

```go
// Atomic deduplication for idempotency keys
idempotencyKey := "process:batch:abc-123"
taskData := []byte("task-payload")

storedValue, wasSet, err := m.cache.GetOrSet(ctx, idempotencyKey, taskData, 10*time.Minute)
if err != nil {
    return err
}

if wasSet {
    // First time processing - execute task
    return processBatch(ctx, taskData)
}

// Duplicate request detected - return cached result
return getCachedResult(storedValue)
```

**Distributed Locking with CompareAndSet:**

```go
// Acquire distributed lock
lockKey := "lock:job:456"
workerID := []byte("worker-1")

success, err := m.cache.CompareAndSet(ctx, lockKey, nil, workerID, 30*time.Second)
if err != nil {
    return err
}

if !success {
    return errors.New("lock already held by another worker")
}

// Lock acquired - perform work
defer m.cache.Delete(ctx, lockKey) // Release lock

return processJob(ctx)
```

**Multi-Tenant Context Propagation:**

```go
import "github.com/gaborage/go-bricks/multitenant"

// HTTP handler - tenant resolved from request headers/hostname
func (h *Handler) GetUser(c echo.Context) error {
    ctx := c.Request().Context()  // Tenant already in context via middleware

    user, err := h.service.GetUser(ctx, userID)  // Uses tenant-specific cache
    return c.JSON(200, user)
}

// Testing multi-tenant cache isolation
func TestMultiTenantCacheIsolation(t *testing.T) {
    // Create mock caches for each tenant
    acmeCache := NewMockCache()
    globexCache := NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            tenantID := multitenant.GetTenant(ctx)
            switch tenantID {
            case "acme":
                return acmeCache, nil
            case "globex":
                return globexCache, nil
            default:
                return nil, errors.New("tenant not found")
            }
        },
    }

    svc := NewUserService(deps)

    // Test with acme tenant
    acmeCtx := multitenant.SetTenant(context.Background(), "acme")
    user1, _ := svc.GetUser(acmeCtx, 123)  // Uses acmeCache

    // Test with globex tenant
    globexCtx := multitenant.SetTenant(context.Background(), "globex")
    user2, _ := svc.GetUser(globexCtx, 123)  // Uses globexCache

    // Verify caches are isolated
    assert.NotEqual(t, user1, user2)  // Different tenant data
}
```

**Operation Reference:**

| Operation | Method | Use Case | Atomicity | Latency |
|-----------|--------|----------|-----------|---------|
| Basic read | Get(ctx, key) | Query result cache | Single-key | ~1ms |
| Basic write | Set(ctx, key, value, ttl) | Store computed result | Single-key | ~1ms |
| Remove | Delete(ctx, key) | Invalidation, lock release | Single-key | ~1ms |
| Deduplication | GetOrSet(ctx, key, value, ttl) | Idempotency keys | Atomic SET NX | ~2ms |
| Distributed lock | CompareAndSet(ctx, key, expected, new, ttl) | Job coordination | Lua script CAS | ~2ms |
| Type-safe store | Marshal(v) + Set() | Struct serialization | Single-key | ~1ms + encode |
| Type-safe retrieve | Get() + Unmarshal[T](data) | Struct deserialization | Single-key | ~1ms + decode |

**Error Handling & Graceful Degradation:**

```go
// Graceful degradation - cache failure doesn't break request
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first with timeout
    cacheCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    defer cancel()

    if cache, err := s.getCache(cacheCtx); err == nil {
        data, err := cache.Get(cacheCtx, cacheKey)
        if err == nil {
            user, err := cache.Unmarshal[User](data)
            if err == nil {
                return user, nil  // Cache hit - return immediately
            }
        }

        // Log cache errors but don't fail the request
        if !errors.Is(err, cache.ErrNotFound) {
            s.logger.Warn("Cache operation failed, falling back to database",
                "error", err, "key", cacheKey)
        }
    }

    // Always query database as fallback
    return s.queryDatabase(ctx, id)
}

// Timeout handling with context
ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
defer cancel()

data, err := cache.Get(ctx, key)
if errors.Is(err, context.DeadlineExceeded) {
    // Cache too slow - fallback to database
    s.logger.Warn("Cache timeout exceeded", "key", key)
}

// Error type checking
if errors.Is(err, cache.ErrNotFound) {
    // Key expired or never set - query database, repopulate cache
} else if errors.Is(err, cache.ErrClosed) {
    // Cache closed during shutdown - skip cache, continue request
} else if errors.Is(err, cache.ErrInvalidTTL) {
    // Developer error - negative or zero TTL provided
} else if opErr, ok := err.(*cache.OperationError); ok {
    // Network/Redis error - includes operation, key, underlying error
    s.logger.Error("Cache operation failed",
        "operation", opErr.Op,
        "key", opErr.Key,
        "error", opErr.Err)
}
```

**Common Error Scenarios:**

| Error | Cause | Recommended Handling |
|-------|-------|---------------------|
| `cache.ErrNotFound` | Key expired or never set | Query database, repopulate cache |
| `cache.ErrClosed` | Cache closed during shutdown | Skip cache, query database directly |
| `cache.ErrInvalidTTL` | Zero or negative TTL provided | Fix code - TTL must be positive |
| `cache.OperationError` | Network/Redis error | Log error, fallback to database |
| `context.DeadlineExceeded` | Operation timeout | Skip cache, continue with database |
| `config.NotConfiguredError` | Cache not enabled | Disable cache features gracefully |

**Health Checks & Monitoring:**

```go
// Cache health check (called by framework /health endpoint)
err := cache.Health(ctx)
if err != nil {
    // Redis: PING command failed
    // Cache unhealthy - alert operations team
}

// Framework automatically includes cache in health endpoint:
// GET /health
// {
//   "status": "healthy",
//   "checks": {
//     "database": "ok",
//     "cache": "ok",       // ← Automatic when cache enabled
//     "messaging": "ok"
//   }
// }

// Cache instance stats (Redis-specific)
stats, err := cache.Stats()
// {
//   "redis_info": {...},          // Redis SERVER INFO
//   "pool_hits": 12500,           // Connection pool hits
//   "pool_misses": 45,            // Connection pool misses
//   "pool_timeouts": 0,           // Pool timeout errors
//   "pool_total_conns": 10,       // Total connections
//   "pool_idle_conns": 7,         // Idle connections
//   "pool_stale_conns": 0         // Stale connections
// }

// CacheManager stats (multi-tenant lifecycle)
managerStats := cacheManager.Stats()
// {
//   "active_caches": 45,      // Current tenant caches
//   "total_created": 128,     // Lifetime cache instances
//   "evictions": 12,          // LRU evictions
//   "idle_cleanups": 71,      // Idle timeout cleanups
//   "errors": 0               // Creation/close errors
// }
```

**Observability Integration:**

When `observability.enabled: true` in config, cache operations automatically emit:

- **Traces:** Spans for Get/Set/Delete operations with `cache.operation`, `cache.key`, `cache.hit` attributes
- **Metrics:**
  - `cache.operation.duration{operation, status}` - Histogram of operation latency
  - `cache.errors.total{operation, error_type}` - Counter of cache errors
  - `cache.manager.active_caches` - Gauge of active tenant caches
- **Logs:** Structured logs with `cache_operation`, `key`, `duration_ms`, `tenant_id` fields

Example OpenTelemetry span:
```
Span: cache.get
  Attributes:
    cache.operation: "get"
    cache.key: "user:123"
    cache.hit: true
    cache.duration_ms: 1.2
    tenant.id: "acme"
```

No code changes required - observability hooks activate automatically when configured.

**Performance Characteristics:**

**Redis Cache Latency (localhost):**
- Get: ~0.5-1ms (single key, no network)
- Set: ~0.5-1ms (single key, no network)
- GetOrSet: ~1-2ms (Lua script execution)
- CompareAndSet: ~1-2ms (Lua script execution)

**Network Latency Impact:**
- Same datacenter: +0.5-1ms additional latency
- Cross-region: +50-200ms (NOT recommended for cache)

**Throughput (single Redis instance):**
- Reads: ~100,000 ops/sec
- Writes: ~80,000 ops/sec
- Mixed workload: ~90,000 ops/sec

**Connection Pool Sizing:**
```yaml
cache:
  redis:
    pool_size: 10  # Default: NumCPU * 2
```

**Rule:** `PoolSize >= (NumCPU * 2 * ConcurrentRequests) / 100`

Example: 8 CPUs, 500 concurrent requests → PoolSize = 80

**Cache vs Alternatives:**

| Scenario | Solution | Reason |
|----------|----------|--------|
| User sessions (shared across pods) | Redis Cache | Distributed state, automatic TTL |
| Query result cache (5min TTL) | Redis Cache | Built-in expiration, no manual cleanup |
| Application config (static) | In-memory `map` | No expiration needed, read-only |
| Rate limiting (per-tenant) | Redis Cache + `GetOrSet` | Atomic operations, distributed |
| Idempotency keys | Redis Cache + `CompareAndSet` | Distributed lock semantics |
| Local caching (per-pod) | `sync.Map` or `ristretto` | No network overhead, pod-local only |
| Distributed locks | Redis Cache + `CompareAndSet` | Cross-pod coordination |

**Cache vs Database Trade-offs:**

| Aspect | Cache (Redis) | Database (PostgreSQL/Oracle) |
|--------|---------------|------------------------------|
| **Durability** | Ephemeral (data loss on restart) | Durable (ACID guarantees) |
| **Latency** | <1ms (localhost) | 5-50ms (query complexity) |
| **Expiration** | Automatic TTL | Manual cleanup required |
| **Consistency** | Best-effort | Strong consistency |
| **Query Capability** | Key-value only | Complex SQL queries |
| **Use Case** | Read-heavy, acceptable staleness | Write-heavy, critical data |

**Rule:** Use cache for read-heavy workloads with acceptable data staleness (TTL-based invalidation).

**Cache Testing Utilities:**

**Note:** GoBricks does not yet provide a `cache/testing` package (similar to `database/testing`). Use interface mocking for now.

```go
import (
    "context"
    "sync"
    "time"

    "github.com/gaborage/go-bricks/cache"
)

// MockCache - Simple in-memory cache for testing
type MockCache struct {
    data map[string][]byte
    mu   sync.RWMutex
}

func NewMockCache() *MockCache {
    return &MockCache{data: make(map[string][]byte)}
}

func (m *MockCache) Get(_ context.Context, key string) ([]byte, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    if val, ok := m.data[key]; ok {
        return val, nil
    }
    return nil, cache.ErrNotFound
}

func (m *MockCache) Set(_ context.Context, key string, value []byte, _ time.Duration) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = value
    return nil
}

func (m *MockCache) Delete(_ context.Context, key string) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    delete(m.data, key)
    return nil
}

func (m *MockCache) GetOrSet(_ context.Context, key string, value []byte, _ time.Duration) ([]byte, bool, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    if existing, ok := m.data[key]; ok {
        return existing, false, nil
    }
    m.data[key] = value
    return value, true, nil
}

func (m *MockCache) CompareAndSet(_ context.Context, key string, expected, new []byte, _ time.Duration) (bool, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    existing, exists := m.data[key]
    if expected == nil && !exists {
        m.data[key] = new
        return true, nil
    }
    if exists && string(existing) == string(expected) {
        m.data[key] = new
        return true, nil
    }
    return false, nil
}

func (m *MockCache) Health(_ context.Context) error {
    return nil
}

func (m *MockCache) Stats() (map[string]any, error) {
    return map[string]any{"entries": len(m.data)}, nil
}

func (m *MockCache) Close() error {
    return nil
}

// Test example with MockCache
func TestUserService_CacheHit(t *testing.T) {
    mockCache := NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
    }

    svc := NewUserService(deps)

    // Pre-populate cache
    user := &User{ID: 123, Name: "Alice"}
    data, _ := cache.Marshal(user)
    mockCache.Set(ctx, "user:123", data, 5*time.Minute)

    // Test cache hit
    result, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", result.Name)
}
```

## Cache Testing Utilities

GoBricks provides `cache/testing` package for easy cache mocking without Redis dependencies (**73% less boilerplate than manual mocks**).

**Mock Cache Setup:**

```go
import cachetest "github.com/gaborage/go-bricks/cache/testing"

func TestUserService(t *testing.T) {
    mockCache := cachetest.NewMockCache()

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
    }

    svc := NewUserService(deps)
    user, err := svc.GetUser(ctx, 123)

    assert.NoError(t, err)
    assert.Equal(t, "Alice", user.Name)
}
```

**Configurable Behavior (Fluent API):**

```go
// Simulate cache failures
mockCache := cachetest.NewMockCache().
    WithGetFailure(cache.ErrConnectionError).
    WithDelay(100 * time.Millisecond)

// Service should gracefully degrade
user, err := svc.GetUser(ctx, 123)  // Falls back to database
assert.NoError(t, err)

// Verify operation counts
cachetest.AssertOperationCount(t, mockCache, "Get", 1)
```

**Available Assertion Helpers:**

```go
// Cache hit/miss assertions
cachetest.AssertCacheHit(t, mockCache, "user:123")
cachetest.AssertCacheMiss(t, mockCache, "missing:key")

// Operation counting
cachetest.AssertOperationCount(t, mockCache, "Get", 5)
cachetest.AssertOperationCountAtLeast(t, mockCache, "Set", 10)  // At least 10 Set operations

// Key existence (ignores expiration)
cachetest.AssertKeyExists(t, mockCache, "key1")
cachetest.AssertKeyNotExists(t, mockCache, "deleted:key")

// Cache state
cachetest.AssertCacheEmpty(t, mockCache)
cachetest.AssertCacheSize(t, mockCache, 3)
cachetest.AssertCacheClosed(t, mockCache)
cachetest.AssertCacheOpen(t, mockCache)

// Value assertions
cachetest.AssertValue(t, mockCache, "key1", []byte("expected-value"))
value := cachetest.AssertGetValue(t, mockCache, "key1")  // Returns value for further checks

// Error assertions
cachetest.AssertError(t, func() error {
    _, err := mockCache.Get(ctx, "key")
    return err
}, cache.ErrNotFound)

cachetest.AssertNoError(t, func() error {
    return mockCache.Set(ctx, "key", []byte("value"), time.Minute)
})
```

**Multi-Tenant Testing:**

```go
import (
    cachetest "github.com/gaborage/go-bricks/cache/testing"
    "github.com/gaborage/go-bricks/multitenant"
)

func TestMultiTenantCacheIsolation(t *testing.T) {
    tenantCaches := map[string]*cachetest.MockCache{
        "acme":   cachetest.NewMockCache(),
        "globex": cachetest.NewMockCache(),
    }

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            tenantID := multitenant.GetTenant(ctx)
            return tenantCaches[tenantID], nil
        },
    }

    svc := NewUserService(deps)

    // Test acme tenant
    acmeCtx := multitenant.SetTenant(context.Background(), "acme")
    user1, _ := svc.GetUser(acmeCtx, 123)

    // Test globex tenant
    globexCtx := multitenant.SetTenant(context.Background(), "globex")
    user2, _ := svc.GetUser(globexCtx, 123)

    // Verify isolation
    cachetest.AssertOperationCount(t, tenantCaches["acme"], "Get", 1)
    cachetest.AssertOperationCount(t, tenantCaches["globex"], "Get", 1)
}
```

**Advanced Configuration:**

```go
// Custom cache ID (useful for tracking multiple instances)
mock := cachetest.NewMockCacheWithID("test-cache-1")

// Failure injection for specific operations
mock := cachetest.NewMockCache().
    WithGetFailure(cache.ErrConnectionError).
    WithSetFailure(cache.ErrClosed).
    WithDeleteFailure(errors.New("custom error"))

// Simulate slow operations (timeout testing)
mock := cachetest.NewMockCache().WithDelay(500 * time.Millisecond)

ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
defer cancel()

_, err := mock.Get(ctx, "key")
assert.ErrorIs(t, err, context.DeadlineExceeded)

// Close callback (lifecycle tracking)
var closedCaches []string
mock := cachetest.NewMockCache().WithCloseCallback(func(id string) {
    closedCaches = append(closedCaches, id)
})
```

**Test Utilities:**

```go
// Reset between test cases
cachetest.ResetMock(mockCache)  // Clears data + counters

// Debugging
counts := cachetest.GetOperationCounts(mockCache)
fmt.Printf("Operations: %+v\n", counts)  // {Get:5, Set:3, Delete:1, ...}

dump := cachetest.DumpCache(mockCache)
t.Log(dump)  // Prints cache contents with expiration info

// Check all stored keys
keys := mockCache.GetAllKeys()
assert.Contains(t, keys, "user:123")

// Stats assertion
stats, _ := mockCache.Stats()
cachetest.AssertStatsContains(t, stats, "entry_count", 5)
```

**Testing Cache-Aside Pattern:**

```go
func TestCacheAsidePattern(t *testing.T) {
    mockCache := cachetest.NewMockCache()
    mockDB := dbtest.NewTestDB(dbtypes.PostgreSQL)

    mockDB.ExpectQuery("SELECT").WillReturnRows(
        dbtest.NewRowSet("id", "name").AddRow(int64(123), "Alice"),
    )

    deps := &app.ModuleDeps{
        GetCache: func(ctx context.Context) (cache.Cache, error) {
            return mockCache, nil
        },
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return mockDB, nil
        },
    }

    svc := NewUserService(deps)
    ctx := context.Background()

    // First call - cache miss, loads from DB
    user1, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", user1.Name)

    // Verify cache miss then set
    cachetest.AssertOperationCount(t, mockCache, "Get", 1)
    cachetest.AssertOperationCount(t, mockCache, "Set", 1)
    dbtest.AssertQueryExecuted(t, mockDB, "SELECT")

    // Second call - cache hit, no DB query
    mockDB.ResetQueryLog()
    user2, err := svc.GetUser(ctx, 123)
    assert.NoError(t, err)
    assert.Equal(t, "Alice", user2.Name)

    // Verify cache hit
    cachetest.AssertOperationCount(t, mockCache, "Get", 2)
    cachetest.AssertOperationCount(t, mockCache, "Set", 1)  // Still 1
    assert.Empty(t, mockDB.QueryLog(), "Should not query DB on cache hit")
}
```

**Testing TTL Expiration:**

```go
func TestCacheTTLExpiration(t *testing.T) {
    mockCache := cachetest.NewMockCache()
    ctx := context.Background()

    // Set with short TTL
    mockCache.Set(ctx, "key1", []byte("value1"), 10*time.Millisecond)

    // Should exist immediately
    cachetest.AssertCacheHit(t, mockCache, "key1")

    // Wait for expiration
    time.Sleep(20 * time.Millisecond)

    // Should be expired
    cachetest.AssertCacheMiss(t, mockCache, "key1")
}
```

**Comparison with Manual Mocking:**

```go
// ❌ MANUAL MOCK (~150 lines of boilerplate)
type manualMockCache struct {
    data    map[string][]byte
    getCalls int
    setCalls int
    mu      sync.Mutex
}

func (m *manualMockCache) Get(ctx context.Context, key string) ([]byte, error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.getCalls++
    val, ok := m.data[key]
    if !ok {
        return nil, cache.ErrNotFound
    }
    return val, nil
}
// ... implement all 8 cache.Cache methods ...

// ✅ cache/testing MockCache (~5 lines)
mock := cachetest.NewMockCache()
// All methods implemented, thread-safe, operation tracking included
```

## Messaging Snapshot

```go
func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	exchange := decls.DeclareTopicExchange("orders.events")
	queue := decls.DeclareQueue("orders.processing")
	decls.DeclareBinding(queue.Name, exchange.Name, "order.*")

	decls.DeclarePublisher(&messaging.PublisherOptions{
		Exchange:   exchange.Name,
		RoutingKey: "order.created",
		EventType:  "OrderCreated",
	}, nil)

	// Default consumer (auto-scales to NumCPU*4 workers)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     queue.Name,
		Consumer:  "order-processor",
		EventType: "OrderCreated",
		Handler:   NewOrderHandler(m.svc, m.logger),
	}, nil)
	// 8-core machine: 32 workers, 320 prefetch

	// Sequential consumer (for ordering-sensitive processing)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     "account.events",
		Consumer:  "account-processor",
		EventType: "AccountUpdated",
		Workers:   1,  // Sequential processing
		Handler:   NewAccountHandler(m.svc, m.logger),
	}, nil)

	// High-concurrency consumer (for batch processing)
	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:         "reports.generate",
		Consumer:      "report-generator",
		EventType:     "ReportRequested",
		Workers:       50,           // High concurrency
		PrefetchCount: 500,          // Large prefetch
		Handler:       NewReportHandler(m.svc, m.logger),
	}, nil)
}
```

| Concern            | Built-in support                                  |
|--------------------|---------------------------------------------------|
| Idempotent setup   | Declarations validated once, replayed per tenant  |
| Error handling     | **No automatic retry** - all errors drop message (prevents infinite loops). Rich ERROR logs + metrics for failed messages. DLQ support planned. |
| **Concurrency (v0.17+)** | **Auto-scales to NumCPU*4 workers** for I/O-bound handlers. Override with `Workers` field. Sequential (`Workers=1`) for ordering. |
| Publishers         | Typed options ensure routing key + event type     |
| Consumers          | Handler receives `context.Context`, `amqp.Delivery`; return error drops message |
| Metrics & tracing  | Automatic OTEL spans + structured logs            |

Use `messaging.Client.Publish(ctx, routingKey, payload)` for runtime sends.

**IMPORTANT:**
- Handler errors do NOT trigger retry. Failed messages are logged (ERROR level) with full context and dropped.
- **v0.17+**: Handlers MUST be thread-safe (auto-scales to NumCPU*4 workers). Test with `go test -race`.
- Database pools must be sized: `MaxOpenConns >= NumCPU * 4 * NumConsumers`

## Multi-Tenancy
- Enable with `multitenant.enabled=true`.
- Resolution strategies: `header`, `host`, or custom store implementing `multitenant.Store`.
- Each tenant gets isolated DB connections, messaging clients, and module lifecycle events.

**Configuration:**

```yaml
multitenant:
  enabled: true
  resolver:
    type: header
    header: X-Tenant-ID
  tenants:
    acme:
      database:
        type: postgresql
        host: acme-db.example.com
        name: acme_production
    globex:
      database:
        type: postgresql
        host: globex-db.example.com
        name: globex_production
```

**Multi-Tenant Service Implementation:**

```go
import (
    "context"
    "errors"
    "fmt"

    "github.com/gaborage/go-bricks/app"
    "github.com/gaborage/go-bricks/database"
    "github.com/gaborage/go-bricks/logger"
    "github.com/gaborage/go-bricks/server"
)

// Service with tenant-aware database access
type UserService struct {
    getDB  func(context.Context) (database.Interface, error)
    logger logger.Logger
}

func NewUserService(getDB func(context.Context) (database.Interface, error), logger logger.Logger) *UserService {
    return &UserService{getDB: getDB, logger: logger}
}

func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    // Resolve tenant-specific database from context
    db, err := s.getDB(ctx)
    if err != nil {
        // Handle missing tenant context (X-Tenant-ID header not provided)
        if errors.Is(err, app.ErrNoTenantInContext) {
            s.logger.Error("Tenant not found in context", "user_id", id)
            return nil, fmt.Errorf("tenant context required: %w", err)
        }
        return nil, fmt.Errorf("database unavailable: %w", err)
    }

    // Query runs against tenant-isolated database
    var user User
    err = db.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id = $1", id).
        Scan(&user.ID, &user.Name, &user.Email)
    if err != nil {
        return nil, fmt.Errorf("query failed: %w", err)
    }

    return &user, nil
}

func (s *UserService) CreateUser(ctx context.Context, name, email string) (*User, error) {
    db, err := s.getDB(ctx)
    if err != nil {
        return nil, err
    }

    var id int64
    err = db.QueryRow(ctx,
        "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id",
        name, email).Scan(&id)
    if err != nil {
        return nil, fmt.Errorf("insert failed: %w", err)
    }

    return &User{ID: id, Name: name, Email: email}, nil
}
```

**Handler Integration (Tenant Context Flows Automatically):**

```go
type Handler struct {
    svc *UserService
}

func NewHandler(getDB func(context.Context) (database.Interface, error), logger logger.Logger) *Handler {
    return &Handler{svc: NewUserService(getDB, logger)}
}

func (h *Handler) GetUser(req GetUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
    // Tenant automatically resolved from X-Tenant-ID header by middleware
    // Context contains tenant ID when multitenant.enabled: true
    reqCtx := ctx.Request().Context()

    user, err := h.svc.GetUser(reqCtx, req.ID)
    if err != nil {
        // Map domain errors to HTTP responses
        if errors.Is(err, app.ErrNoTenantInContext) {
            return server.Result[User]{}, server.BadRequest(errors.New("X-Tenant-ID header required"))
        }
        return server.Result[User]{}, server.InternalServerError(err)
    }

    return server.OK(user), nil
}

type GetUserReq struct {
    ID int64 `param:"id" validate:"required,gt=0"`
}
```

**Complete Request Flow:**

```
1. HTTP Request with header: X-Tenant-ID: acme
2. Middleware extracts tenant ID → sets in context via multitenant.SetTenant(ctx, "acme")
3. Handler calls service.GetUser(reqCtx, id)
4. Service calls getDB(ctx) → framework resolves acme's database connection
5. Query runs against acme_production database
6. Response returned to acme tenant
```

**Error Handling Reference:**

| Error | HTTP Status | User Message |
|-------|-------------|--------------|
| `app.ErrNoTenantInContext` | 400 | "X-Tenant-ID header required" |
| `app.ErrTenantNotFound` | 404 | "Tenant not configured" |
| Database connection error | 503 | "Service temporarily unavailable" |
| Query error | 500 | "Internal server error" |

### Shared Database Multi-Tenancy (Same DB Instance)

When you need multiple tenants in the **same database instance** (cost optimization, simpler operations), use tenant_id column filtering instead of separate databases.

**1. Database Schema - Add tenant_id to all tables:**

```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    tenant_id VARCHAR(50) NOT NULL,  -- Tenant identifier
    email VARCHAR(255) NOT NULL,
    name VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT unique_email_per_tenant UNIQUE (tenant_id, email)
);

CREATE INDEX idx_users_tenant ON users(tenant_id);
```

**2. Entity with tenant_id field:**

```go
type User struct {
    ID       int64  `db:"id"`
    TenantID string `db:"tenant_id"`
    Email    string `db:"email"`
    Name     string `db:"name"`
}
```

**3. Service with tenant-aware queries:**

```go
import (
    "context"
    "errors"

    "github.com/gaborage/go-bricks/database"
    "github.com/gaborage/go-bricks/database/internal/builder"
    "github.com/gaborage/go-bricks/multitenant"
)

type UserService struct {
    getDB func(context.Context) (database.Interface, error)
}

func (s *UserService) FindByEmail(ctx context.Context, email string) (*User, error) {
    // Extract tenant from context (set by TenantMiddleware)
    tenantID, ok := multitenant.GetTenant(ctx)
    if !ok {
        return nil, errors.New("tenant context required")
    }

    db, err := s.getDB(ctx)
    if err != nil {
        return nil, err
    }

    qb := builder.NewQueryBuilder(db.DatabaseType())
    cols := qb.Columns(&User{})
    f := qb.Filter()

    // Always filter by tenant_id for data isolation
    sql, args := qb.Select(cols.All()...).
        From("users").
        Where(f.And(
            f.Eq(cols.Col("TenantID"), tenantID),  // Tenant isolation
            f.Eq(cols.Col("Email"), email),
        )).
        ToSQL()

    var user User
    err = db.QueryRow(ctx, sql, args...).Scan(&user.ID, &user.TenantID, &user.Email, &user.Name)
    if err != nil {
        return nil, err
    }
    return &user, nil
}

func (s *UserService) Create(ctx context.Context, email, name string) (*User, error) {
    tenantID, ok := multitenant.GetTenant(ctx)
    if !ok {
        return nil, errors.New("tenant context required")
    }

    db, _ := s.getDB(ctx)
    qb := builder.NewQueryBuilder(db.DatabaseType())
    cols := qb.Columns(&User{})

    // Always include tenant_id in INSERT
    sql, args := qb.Insert("users").
        Columns(cols.Col("TenantID"), cols.Col("Email"), cols.Col("Name")).
        Values(tenantID, email, name).
        Suffix("RETURNING id").
        ToSQL()

    var id int64
    err := db.QueryRow(ctx, sql, args...).Scan(&id)
    return &User{ID: id, TenantID: tenantID, Email: email, Name: name}, err
}

func (s *UserService) List(ctx context.Context, status string) ([]User, error) {
    tenantID, _ := multitenant.GetTenant(ctx)
    db, _ := s.getDB(ctx)

    qb := builder.NewQueryBuilder(db.DatabaseType())
    cols := qb.Columns(&User{})
    f := qb.Filter()

    // Tenant isolation + business filter
    sql, args := qb.Select(cols.All()...).
        From("users").
        Where(f.And(
            f.Eq(cols.Col("TenantID"), tenantID),  // Always filter by tenant
            f.Eq(cols.Col("Status"), status),       // Business filter
        )).
        ToSQL()

    rows, err := db.Query(ctx, sql, args...)
    // ... iterate rows
}
```

**4. Configuration (Single shared database):**

```yaml
# Shared database for ALL tenants (no per-tenant database config)
database:
  type: postgresql
  host: shared-db.example.com
  database: app_production  # Single database

multitenant:
  enabled: true
  resolver:
    type: header
    header: X-Tenant-ID
  # No tenants.*.database section needed - uses shared database above
```

**5. Helper function to reduce boilerplate:**

```go
// WithTenantFilter adds tenant isolation to any query
func WithTenantFilter(ctx context.Context, f *builder.Filter, cols dbtypes.ColumnMetadata) builder.Condition {
    tenantID, _ := multitenant.GetTenant(ctx)
    return f.Eq(cols.Col("TenantID"), tenantID)
}

// Usage in queries:
sql, args := qb.Select(cols.All()...).
    From("orders").
    Where(f.And(
        WithTenantFilter(ctx, f, cols),  // Tenant isolation
        f.Eq(cols.Col("Status"), "pending"),
    )).
    ToSQL()
```

**Strategy Comparison:**

| Strategy | Isolation | Cost | Complexity | Use Case |
|----------|-----------|------|------------|----------|
| **Database-per-tenant** | Strongest | Higher (N databases) | Lower code | Enterprise, regulated industries |
| **Shared DB + tenant_id** | Application-level | Lower (1 database) | Higher code (manual filtering) | SaaS startups, cost-sensitive |
| **Schema-per-tenant** | Strong | Medium | Medium | PostgreSQL-specific, balanced |

**Key Points:**
- **Always** include `tenant_id` in WHERE clauses for SELECT/UPDATE/DELETE
- **Always** include `tenant_id` in INSERT statements
- Use `multitenant.GetTenant(ctx)` to extract tenant from request context
- Add composite indexes on `(tenant_id, other_columns)` for query performance
- Consider PostgreSQL Row-Level Security (RLS) for additional database-level protection

## Observability & Logging

**Basic Configuration:**

```yaml
# config.yaml (base config, committed to git)
observability:
  enabled: true
  service:
    name: my-service
    version: v1.0.0
  traces:
    enabled: true
    endpoint: http://localhost:4318/v1/traces
    protocol: http
  metrics:
    enabled: true
  logs:
    enabled: true
    slow_request_threshold: 750ms

logger:
  pretty: false  # MUST be false when observability.logs.enabled = true
  level: info
```

**New Relic Production Config (Optimized with Compression):**

```yaml
# config.production.yaml (DO NOT commit - add to .gitignore)
observability:
  enabled: true
  service:
    name: my-service
    version: v1.0.0

  # Traces with gRPC compression
  trace:
    enabled: true
    endpoint: otlp.nr-data.net:4317  # No https:// for gRPC!
    protocol: grpc
    compression: gzip  # ~70% bandwidth reduction
    insecure: false  # TLS required for New Relic
    headers:
      api-key: your-new-relic-license-key  # Secret value

  # Metrics with New Relic optimizations
  metrics:
    enabled: true
    endpoint: otlp.nr-data.net:4317  # No https:// for gRPC!
    protocol: grpc
    compression: gzip
    temporality: delta  # New Relic recommendation (lower memory)
    histogram_aggregation: exponential  # Better precision, 10x lower memory
    headers:
      api-key: your-new-relic-license-key  # Reuse or separate key

  # Logs with compression and sampling
  logs:
    enabled: true
    endpoint: otlp.nr-data.net:4317  # No https:// for gRPC!
    protocol: grpc
    compression: gzip
    sampling_rate: 0.1  # Export 10% of INFO/DEBUG logs (ERROR/WARN always sent)
    headers:
      api-key: your-new-relic-license-key

logger:
  pretty: false  # MUST be false when observability.logs.enabled = true
  level: info
```

**HTTP Alternative (Port 4318 with Signal Paths):**

```yaml
observability:
  enabled: true
  service:
    name: my-service

  trace:
    enabled: true
    endpoint: https://otlp.nr-data.net:4318/v1/traces  # HTTP requires https:// + path
    protocol: http
    compression: gzip
    headers:
      api-key: your-license-key

  metrics:
    enabled: true
    endpoint: https://otlp.nr-data.net:4318/v1/metrics  # Signal-specific path
    protocol: http
    compression: gzip
    temporality: delta
    histogram_aggregation: exponential
    headers:
      api-key: your-license-key

  logs:
    enabled: true
    endpoint: https://otlp.nr-data.net:4318/v1/logs  # Signal-specific path
    protocol: http
    compression: gzip
    headers:
      api-key: your-license-key

logger:
  pretty: false
```

**With OTEL Collector (Recommended for Production):**

```yaml
# Application config - collector handles vendor specifics
observability:
  enabled: true
  service:
    name: my-service
    version: v1.0.0

  trace:
    endpoint: otel-collector:4317  # Local collector
    protocol: grpc
    insecure: true  # Collector on same network (no TLS)
    compression: gzip  # Reduce app→collector traffic

  metrics:
    enabled: true
    endpoint: otel-collector:4317
    protocol: grpc
    compression: gzip
    temporality: delta
    histogram_aggregation: exponential

  logs:
    enabled: true
    endpoint: otel-collector:4317
    protocol: grpc
    compression: gzip
    sampling_rate: 0.2  # 20% trace logs

logger:
  pretty: false
```

**Security: Never commit secrets to git**

```bash
# .gitignore
config.production.yaml
config.staging.yaml
config.*.local.yaml
```

**Alternative: Load secrets from environment in code**

```go
// main.go
cfg, _ := config.Load()

// Override headers with secrets from env/vault
apiKey := os.Getenv("OTEL_API_KEY")
cfg.Observability.Traces.Headers = map[string]string{"api-key": apiKey}
cfg.Observability.Metrics.Headers = map[string]string{"api-key": apiKey}
cfg.Observability.Logs.Headers = map[string]string{"api-key": apiKey}

app.Run(cfg)
```

**Endpoint Format Rules (CRITICAL):**

| Protocol | Format | Example | TLS |
|----------|--------|---------|-----|
| `grpc` | `host:port` (NO scheme) | `otlp.nr-data.net:4317` | Auto |
| `grpc` (insecure) | `host:port` + `insecure: true` | `localhost:4317` | Off |
| `http` | `https://host:port/path` | `https://otlp.nr-data.net:4318/v1/traces` | On |
| `http` (insecure) | `http://host:port/path` | `http://localhost:4318/v1/traces` | Off |

**Common Mistakes:**
- ❌ `https://otlp.nr-data.net:4317` + `protocol: grpc` → ERROR: "too many colons"
- ✅ `otlp.nr-data.net:4317` + `protocol: grpc` → Correct

**Common Vendor Headers:**

| Vendor | Header Example |
|--------|----------------|
| New Relic | `api-key: your-license-key` |
| Honeycomb | `x-honeycomb-team: your-team-key` |
| Datadog | `dd-api-key: your-api-key` |
| Grafana Cloud | `authorization: "Basic base64-creds"` |
| Generic | `authorization: "Bearer your-token"` |

**Insecure gRPC (localhost testing):**
```yaml
traces:
  endpoint: localhost:4317
  protocol: grpc
  insecure: true  # Disable TLS
```

Set `GOBRICKS_DEBUG=true` to emit `[OBSERVABILITY]` diagnostics during local runs.

## Structured Logging with Custom Fields

```go
import (
	"context"
	"time"

	"github.com/gaborage/go-bricks/logger"
)

// === Basic Informational Log with Custom Fields ===

logger.Info().
	Str("user_id", "alice@example.com").
	Str("action", "login").
	Msg("User logged in successfully")
// Output: {"level":"info","user_id":"alice@example.com","action":"login","message":"User logged in successfully"}

// === Multiple Field Types in Single Log ===

logger.Info().
	Str("order_id", "ord_12345").
	Int("item_count", 3).
	Int64("total_cents", 4999).
	Dur("processing_time", 150*time.Millisecond).
	Interface("metadata", map[string]string{"source": "web", "region": "us-west"}).
	Msg("Order processed")

// === Error Logging with Context ===

logger.Error().
	Err(err).
	Str("operation", "payment_process").
	Str("payment_id", "pay_789").
	Int64("amount", 5000).
	Msg("Payment processing failed")

// === Using WithContext for Trace Correlation ===
// Automatically adds trace_id and span_id from OpenTelemetry context

func (h *Handler) ProcessOrder(ctx context.Context, orderID string) error {
	// Inject trace/span IDs from context - enables log correlation in trace viewer
	ctxLogger := h.logger.WithContext(ctx)

	ctxLogger.Info().
		Str("order_id", orderID).
		Msg("Starting order processing")

	// All subsequent logs include trace_id for correlation
	if err := h.processPayment(ctx, orderID); err != nil {
		ctxLogger.Error().
			Err(err).
			Str("order_id", orderID).
			Msg("Payment processing failed")
		return err
	}

	ctxLogger.Info().
		Str("order_id", orderID).
		Str("status", "completed").
		Msg("Order processed successfully")

	return nil
}

// === Using WithFields for Persistent Module Context ===
// Fields added here appear in ALL subsequent logs from this logger

func (m *Module) Init(deps *app.ModuleDeps) error {
	m.logger = deps.Logger.WithFields(map[string]any{
		"module":  m.Name(),
		"version": "1.2.0",
	})
	return nil
}
// All logs from m.logger now include "module" and "version" fields automatically

// === Complete Handler Example with Structured Logging ===

type CreateUserReq struct {
	Email string `json:"email" validate:"required,email"`
	Role  string `json:"role" validate:"required,oneof=admin user guest"`
}

func (h *Handler) CreateUser(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	log := h.logger.WithContext(ctx.Request().Context())

	log.Info().
		Str("email", req.Email).
		Str("role", req.Role).
		Msg("Creating new user")

	user, err := h.service.Create(ctx.Request().Context(), req)
	if err != nil {
		log.Error().
			Err(err).
			Str("email", req.Email).
			Msg("User creation failed")
		return server.Result[User]{}, server.InternalServerError(err)
	}

	log.Info().
		Str("user_id", user.ID).
		Str("email", user.Email).
		Msg("User created successfully")

	return server.Created(user), nil
}
```

| Method | Field Type | Example |
|--------|------------|---------|
| `Str(key, val)` | String | `Str("user_id", "123")` |
| `Int(key, val)` | Integer | `Int("count", 5)` |
| `Int64(key, val)` | Int64 | `Int64("total", 9999999)` |
| `Dur(key, val)` | Duration (ms) | `Dur("elapsed", 150*time.Millisecond)` |
| `Err(err)` | Error | `Err(err)` (adds "error" field) |
| `Interface(key, val)` | Any type | `Interface("meta", map[string]any{...})` |
| `Bytes(key, val)` | Byte slice | `Bytes("hash", hashBytes)` |

**Key Patterns:**
- `logger.WithContext(ctx)` → Injects trace_id/span_id for correlation
- `logger.WithFields(map)` → Persistent fields for all subsequent logs
- Fluent API: chain methods → end with `.Msg("message")`

## Distributed Tracing (Custom Spans)

**HTTP requests are automatically traced** when `observability.enabled: true`. Each incoming request creates a span:
- Span name: `HTTP {method} {route}` (e.g., `HTTP POST /users`)
- Attributes: `http.method`, `http.route`, `http.status_code`, `http.request.body_size`
- W3C `traceparent` header propagation (cross-service tracing)

**No code changes required for basic tracing** — just enable in config.

**Adding Custom Spans in Modules:**

```go
import (
    "context"

    "github.com/gaborage/go-bricks/app"
    "github.com/gaborage/go-bricks/database"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
)

type OrderModule struct {
    tracer trace.Tracer  // Store tracer for custom spans
    getDB  func(context.Context) (database.Interface, error)
}

func (m *OrderModule) Init(deps *app.ModuleDeps) error {
    m.tracer = deps.Tracer  // Injected by framework
    m.getDB = deps.DB
    return nil
}

// Create custom spans for business operations
func (m *OrderModule) ProcessOrder(ctx context.Context, orderID int64) error {
    // Create child span under HTTP request span
    ctx, span := m.tracer.Start(ctx, "ProcessOrder")
    defer span.End()

    // Add attributes for debugging in trace viewer
    span.SetAttributes(
        attribute.Int64("order.id", orderID),
        attribute.String("order.status", "processing"),
    )

    db, err := m.getDB(ctx)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, "database unavailable")
        return err
    }

    // Database operations automatically inherit trace context
    _, err = db.Exec(ctx, "UPDATE orders SET status = $1 WHERE id = $2", "processed", orderID)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
        return err
    }

    span.SetAttributes(attribute.String("order.status", "completed"))
    return nil
}

// Nested spans for complex operations
func (m *OrderModule) ProcessOrderWithPayment(ctx context.Context, orderID int64) error {
    ctx, parentSpan := m.tracer.Start(ctx, "ProcessOrderWithPayment")
    defer parentSpan.End()

    // Child span 1: validate order
    ctx, validateSpan := m.tracer.Start(ctx, "ValidateOrder")
    if err := m.validateOrder(ctx, orderID); err != nil {
        validateSpan.RecordError(err)
        validateSpan.End()
        return err
    }
    validateSpan.End()

    // Child span 2: process payment
    ctx, paymentSpan := m.tracer.Start(ctx, "ProcessPayment")
    if err := m.processPayment(ctx, orderID); err != nil {
        paymentSpan.RecordError(err)
        paymentSpan.End()
        return err
    }
    paymentSpan.End()

    return nil
}
```

**End-to-End Trace Flow:**

```
HTTP Request (traceparent header)
    ↓
Auto-span: "HTTP POST /orders/123/process"
    ↓
Custom span: "ProcessOrderWithPayment"
    ├── Child span: "ValidateOrder"
    │       └── DB span: "db.query" (auto-traced)
    └── Child span: "ProcessPayment"
            └── HTTP span: "HTTP POST /payments" (outgoing call)
    ↓
Response (trace_id in logs)
```

**Trace Context Propagation (Cross-Service):**

```go
import "go.opentelemetry.io/otel/propagation"

// Outgoing HTTP request automatically propagates trace context
func (s *Service) CallExternalAPI(ctx context.Context, data []byte) error {
    req, _ := http.NewRequestWithContext(ctx, "POST", "https://api.example.com/process", bytes.NewReader(data))

    // Inject trace headers (W3C traceparent) - automatic when using otelhttp
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))

    resp, err := http.DefaultClient.Do(req)
    // ... handle response
}
```

**Viewing Traces:**
- Traces export to configured OTLP endpoint (New Relic, Jaeger, Zipkin, etc.)
- Each trace shows: request duration, child spans, errors, custom attributes
- Filter by `service.name`, `http.route`, custom attributes

## Custom Metrics

GoBricks exposes `MeterProvider` via `ModuleDeps` for creating application-specific metrics. When `observability.enabled: false`, a no-op provider is used with zero overhead.

**Module Setup Pattern:**

```go
package orders

import (
    "context"
    "time"

    "github.com/gaborage/go-bricks/app"
    "github.com/gaborage/go-bricks/observability"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/metric"
)

type OrderModule struct {
    // Store MeterProvider for creating instruments
    meterProvider metric.MeterProvider

    // Pre-created instruments (performance optimization)
    orderCounter      metric.Int64Counter
    processingTime    metric.Float64Histogram
    activeConnections metric.Int64UpDownCounter
}

func (m *OrderModule) Init(deps *app.ModuleDeps) error {
    m.meterProvider = deps.MeterProvider

    // Create instruments once in Init() - cached for lifetime of module
    if m.meterProvider != nil {
        meter := m.meterProvider.Meter("orders")

        // Counter: monotonically increasing values (requests, errors)
        m.orderCounter, _ = observability.CreateCounter(
            meter,
            "orders.created.total",
            "Total number of orders created",
        )

        // Histogram: value distributions (latency, size)
        m.processingTime, _ = observability.CreateHistogram(
            meter,
            "orders.processing.duration",
            "Order processing duration in seconds",
        )

        // UpDownCounter: values that increase/decrease (connections, queue depth)
        m.activeConnections, _ = observability.CreateUpDownCounter(
            meter,
            "orders.connections.active",
            "Active order processing connections",
        )
    }

    return nil
}
```

**Recording Metrics with Attributes:**

```go
func (s *OrderService) CreateOrder(ctx context.Context, req CreateOrderRequest) (*Order, error) {
    start := time.Now()

    // Track active processing
    if s.activeConnections != nil {
        s.activeConnections.Add(ctx, 1)
        defer s.activeConnections.Add(ctx, -1)
    }

    order, err := s.processOrder(ctx, req)

    // Record metrics with dimensional attributes
    if s.orderCounter != nil {
        status := "success"
        if err != nil {
            status = "failure"
        }
        s.orderCounter.Add(ctx, 1,
            metric.WithAttributes(
                attribute.String("status", status),
                attribute.String("order_type", req.Type),
                attribute.String("region", req.Region),
            ),
        )
    }

    // Record processing duration
    if s.processingTime != nil {
        s.processingTime.Record(ctx, time.Since(start).Seconds(),
            metric.WithAttributes(
                attribute.String("order_type", req.Type),
            ),
        )
    }

    return order, err
}
```

**Observable Gauge (Callback Pattern):**

For metrics that report current state rather than accumulated values (e.g., current queue size, memory usage):

```go
func (m *QueueModule) Init(deps *app.ModuleDeps) error {
    if deps.MeterProvider != nil {
        meter := deps.MeterProvider.Meter("queue")

        // Observable gauge with callback - called on each metrics collection
        _, _ = meter.Int64ObservableGauge(
            "queue.depth",
            metric.WithDescription("Current number of items in queue"),
            metric.WithInt64Callback(func(ctx context.Context, observer metric.Int64Observer) error {
                // Report current queue size for each queue
                for name, queue := range m.queues {
                    observer.Observe(int64(queue.Len()),
                        metric.WithAttributes(
                            attribute.String("queue.name", name),
                        ),
                    )
                }
                return nil
            }),
        )
    }
    return nil
}
```

**Metric Types Quick Reference:**

| Type | Use Case | Example |
|------|----------|---------|
| `Int64Counter` | Monotonically increasing counts | Requests, errors, events |
| `Float64Histogram` | Value distributions | Latency (seconds), payload size (bytes) |
| `Int64UpDownCounter` | Values that can increase/decrease | Active connections, queue depth |
| `Int64ObservableGauge` | Current state via callback | Memory usage, pool size |
| `Float64ObservableGauge` | Current float state via callback | CPU percentage, temperature |

**Helper Functions (observability/metrics.go):**

```go
// CreateCounter creates a counter with description
counter, err := observability.CreateCounter(meter, "name", "description")

// CreateHistogram creates a histogram with description
histogram, err := observability.CreateHistogram(meter, "name", "description")

// CreateUpDownCounter creates an up-down counter with description
upDown, err := observability.CreateUpDownCounter(meter, "name", "description")
```

**Best Practices:**

1. **Pre-create instruments in Init()** - Avoid per-request instrument creation (expensive)
2. **Use semantic naming**: `<namespace>.<entity>.<measurement>` (e.g., `orders.processing.duration`)
3. **Add attributes for dimensions** - Enable filtering/grouping in dashboards
4. **Nil-check instruments** - Safe when observability disabled
5. **Use appropriate units** - Seconds for duration, bytes for size (follow UCUM conventions)

**Testing Custom Metrics:**

```go
import (
    "testing"

    "go.opentelemetry.io/otel/metric/noop"
)

func TestOrderModule(t *testing.T) {
    // Use no-op meter provider for unit tests
    deps := &app.ModuleDeps{
        MeterProvider: noop.NewMeterProvider(),
    }

    module := &OrderModule{}
    err := module.Init(deps)
    assert.NoError(t, err)

    // Instruments are created but no-ops - safe to call
    module.orderCounter.Add(context.Background(), 1)
}
```

## Common Patterns
- **Error handling**: wrap service errors with `server.InternalServerError`; map domain errors to `server.NotFound`, `server.Unauthorized`, etc.
- **Graceful shutdown**: close external resources in `Module.Shutdown`; the framework waits on outstanding requests.
- **Configuration injection**: `deps.Config.InjectInto(&cfgStruct)` honors defaults and env overrides.
- **Testing**: `obtest.NewTestTraceProvider()` captures spans/logs; mock `database.Interface` and `messaging.Client` directly.
