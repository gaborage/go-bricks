# GoBricks Framework

Enterprise Go microservice toolkit (Go 1.24+). Provides multi-database access, typed HTTP handlers, AMQP messaging, tenant isolation, and built-in OpenTelemetry.

## Quick Start
- `go get github.com/gaborage/go-bricks`
- Scaffold:

```go
package main

import (
	"log"

	"github.com/gaborage/go-bricks/app"
	"github.com/gaborage/go-bricks/config"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}
	fw, err := app.NewWithConfig(cfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	fw.RegisterModules(/* modules */)
	log.Fatal(fw.Run())
}
```

## Config Snapshot

```yaml
app:
  name: my-service
  environment: development
server:
  enabled: true
  port: 8080
database:
  type: postgres # postgres | oracle | mongo
logger:
  level: info
  pretty: true
```

`env vars > config.<env>.yaml > config.yaml > struct defaults`.
Add observability settings as needed (see Observability & Logging).

## Core Concepts
- Framework injects dependencies via `*app.ModuleDeps`; avoid constructing raw `*sql.DB`.
- Declarative messaging defines exchanges, queues, bindings, publishers, and consumers once; the framework replays per tenant.
- Observability hooks (traces, metrics, structured logs) activate when `observability.enabled=true`.
- Multi-tenant mode resolves tenants (header/host/custom store) and hands each module tenant-specific resources.

## Module Skeleton

```go
type Module struct {
	db     database.Interface
	logger logger.Logger
}

func (m *Module) Name() string { return "mymodule" }

func (m *Module) Init(deps *app.ModuleDeps) error {
	m.db = deps.DB
	m.logger = deps.Logger.WithFields(map[string]any{"module": m.Name()})
	return nil
}

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, e *echo.Echo) {
	handler := NewHandler(m.db, m.logger)
	server.POST(hr, e, "/users", handler.Create)
}

func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	// optional
}

func (m *Module) Shutdown() error { return nil }
```

## Typed HTTP Handlers

```go
type CreateUserReq struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required,email"`
}

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (h *Handler) Create(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	user, err := h.svc.Create(ctx.Request().Context(), req)
	if err != nil {
		return server.Result[User]{}, server.InternalServerError(err)
	}
	return server.Created(user), nil
}
```

| Pattern          | Request binding              | Success helper          | Notes                          |
|------------------|------------------------------|-------------------------|--------------------------------|
| POST create      | JSON struct w/ validators    | `server.Created(data)`  | 422 auto-emitted on validation |
| GET lookup       | `server.NoBody` + `ctx.Param`| `server.OK(data)`       | Return domain errors as API    |
| LIST with query  | `query:"..."` struct tags    | `server.OK(list)`       | Query params auto-bound        |
| DELETE           | `server.NoBody`              | `server.NoContent()`    | Return typed API errors        |
| ASYNC acceptance | Request struct               | `server.Accepted(meta)` | For enqueue-style workflows    |

## Database Builder & Operations

```go
qb := builder.NewQueryBuilder(m.db.DatabaseType())
f := qb.Filter()

sql, args := qb.Select("id", "email").
	From("users").
	Where(f.And(f.Eq("status", "active"), f.Like("email", "%@example.com"))).
	ToSQL()

rows, err := m.db.Query(ctx, sql, args...)
```

| Need                | Builder call / API usage                                               |
|---------------------|------------------------------------------------------------------------|
| Filtering           | `f.Eq`, `f.And`, `f.Or`, `f.In`, `f.Between`                           |
| Sorting / grouping  | `query.OrderBy(qb.Expr("created_at DESC"))`, `GroupBy("tenant_id")`    |
| Mutations           | `qb.Insert`, `qb.Update`, `qb.Delete`, then `db.Exec`                  |
| Joins               | `qb.JoinOn` with `qb.JoinFilter()`                                     |
| Subqueries          | Compose another builder clause then `f.Exists(subQuery)`               |
| Transactions        | `tx, _ := db.Begin(ctx)` → `tx.Exec` / `tx.Query` → `tx.Commit()`       |

Access to vendor quirks (Oracle quoting, Mongo builders) routes through the same interface; switching drivers requires config only.

## Messaging Snapshot

```go
func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	exchange := decls.DeclareTopicExchange("orders.events")
	queue := decls.DeclareQueue("orders.processing")
	decls.DeclareBinding(queue.Name, exchange.Name, "order.*")

	decls.DeclarePublisher(&messaging.PublisherOptions{
		Exchange:   exchange.Name,
		RoutingKey: "order.created",
		EventType:  "OrderCreated",
	}, nil)

	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     queue.Name,
		Consumer:  "order-processor",
		EventType: "OrderCreated",
		Handler:   NewOrderHandler(m.svc, m.logger),
	}, nil)
}
```

| Concern            | Built-in support                                  |
|--------------------|---------------------------------------------------|
| Idempotent setup   | Declarations validated once, replayed per tenant  |
| Retry / DLQ        | Queue options: `DeadLetterExchange`, `TTL`, etc.  |
| Publishers         | Typed options ensure routing key + event type     |
| Consumers          | Handler receives `context.Context`, `amqp.Delivery`|
| Metrics & tracing  | Automatic OTEL spans + structured logs            |

Use `messaging.Client.Publish(ctx, routingKey, payload)` for runtime sends.

## Multi-Tenancy
- Enable with `multitenant.enabled=true`.
- Resolution strategies: `header`, `host`, or custom store implementing `multitenant.Store`.
- Each tenant gets isolated DB connections, messaging clients, and module lifecycle events.

```yaml
multitenant:
  enabled: true
  tenant_resolution:
    strategy: header
    header_name: X-Tenant-ID
```

## Observability & Logging

```yaml
observability:
  enabled: true
  service_name: my-service
  trace: { enabled: true, endpoint: "http://otel-collector:4318", protocol: grpc }
  metrics: { enabled: true }
  logs:
    enabled: true
    slow_request_threshold: 750ms

logger:
  pretty: false # set false when exporting to OTLP
  level: info
```

Set `GOBRICKS_DEBUG=true` to emit `[OBSERVABILITY]` diagnostics during local runs.

## Common Patterns
- **Error handling**: wrap service errors with `server.InternalServerError`; map domain errors to `server.NotFound`, `server.Unauthorized`, etc.
- **Graceful shutdown**: close external resources in `Module.Shutdown`; the framework waits on outstanding requests.
- **Configuration injection**: `deps.Config.InjectInto(&cfgStruct)` honors defaults and env overrides.
- **Testing**: `obtest.NewTestTraceProvider()` captures spans/logs; mock `database.Interface` and `messaging.Client` directly.
