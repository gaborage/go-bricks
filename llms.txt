# GoBricks Framework

Enterprise Go microservice toolkit (Go 1.24+). Provides multi-database access, typed HTTP handlers, AMQP messaging, tenant isolation, and built-in OpenTelemetry.

## Quick Start
- `go get github.com/gaborage/go-bricks`
- Scaffold:

```go
package main

import (
	"log"

	"github.com/gaborage/go-bricks/app"
	"github.com/gaborage/go-bricks/config"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}
	fw, err := app.NewWithConfig(cfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	fw.RegisterModules(/* modules */)
	log.Fatal(fw.Run())
}
```

## Config Snapshot

```yaml
app:
  name: my-service
  environment: development
server:
  enabled: true
  port: 8080
database:
  type: postgres # postgres | oracle | mongo
logger:
  level: info
  pretty: true
```

`Highest precedence first: env vars > config.<env>.yaml > config.yaml > struct defaults.`
Add observability settings as needed (see Observability & Logging).

## Core Concepts
- Framework injects dependencies via `*app.ModuleDeps`; avoid constructing raw `*sql.DB`.
- Declarative messaging defines exchanges, queues, bindings, publishers, and consumers once; the framework replays per tenant.
- Observability hooks (traces, metrics, structured logs) activate when `observability.enabled=true`.
- Multi-tenant mode resolves tenants (header/host/custom store) and hands each module tenant-specific resources.

## Module Skeleton

```go
type Module struct {
	db     database.Interface
	logger logger.Logger
}

func (m *Module) Name() string { return "mymodule" }

func (m *Module) Init(deps *app.ModuleDeps) error {
	m.db = deps.DB
	m.logger = deps.Logger.WithFields(map[string]any{"module": m.Name()})
	return nil
}

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, e *echo.Echo) {
	handler := NewHandler(m.db, m.logger)
	server.POST(hr, e, "/users", handler.Create)
}

func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	// optional
}

func (m *Module) Shutdown() error { return nil }
```

## Typed HTTP Handlers

```go
type CreateUserReq struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required,email"`
}

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (h *Handler) Create(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	reqCtx := ctx.Request().Context()
	user, err := h.svc.Create(reqCtx, req)
	if err != nil {
		return server.Result[User]{}, server.InternalServerError(err)
	}
	return server.Created(user), nil
}
```

| Pattern          | Request binding              | Success helper          | Notes                          |
|------------------|------------------------------|-------------------------|--------------------------------|
| POST create      | JSON struct w/ validators    | `server.Created(data)`  | 422 auto-emitted on validation |
| GET lookup       | `server.NoBody` + `ctx.Param`| `server.OK(data)`       | Return domain errors as API    |
| LIST with query  | `query:"..."` struct tags    | `server.OK(list)`       | Query params auto-bound        |
| DELETE           | `server.NoBody`              | `server.NoContent()`    | Return typed API errors        |
| ASYNC acceptance | Request struct               | `server.Accepted(meta)` | For enqueue-style workflows    |

## Database Builder & Operations

```go
// Define entity with db tags
type User struct {
    ID     int64  `db:"id"`
    Email  string `db:"email"`
    Status string `db:"status"`
}

qb := builder.NewQueryBuilder(m.db.DatabaseType())
f := qb.Filter()
cols := qb.Columns(&User{})

sql, args := qb.Select(cols.Fields("ID", "Email")...).
	From("users").
	Where(f.And(
		f.Eq(cols.Col("Status"), "active"),
		f.Like(cols.Col("Email"), "%@example.com"),
	)).
	ToSQL()

ctx := context.Background() // or propagate incoming request context
rows, err := m.db.Query(ctx, sql, args...)
```

| Need                | Builder call / API usage                                               |
|---------------------|------------------------------------------------------------------------|
| Filtering           | `f.Eq`, `f.And`, `f.Or`, `f.In`, `f.Between`                           |
| Sorting / grouping  | `qb.Select(...).From("...").OrderBy(qb.Expr("created_at DESC")).GroupBy("tenant_id")` |
| Mutations           | `qb.Insert`, `qb.Update`, `qb.Delete`, then `db.Exec`                  |
| Joins               | `qb.JoinOn` with `qb.JoinFilter()`                                     |
| Subqueries          | Compose another builder clause then `f.Exists(subQuery)`               |
| Transactions        | `tx, err := db.Begin(ctx); if err != nil { return err }; defer tx.Rollback(ctx); /* work */; if err := tx.Commit(ctx); err != nil { return err }` |

**Mutation Examples (INSERT/UPDATE/DELETE):**

```go
// INSERT
sql, args := qb.Insert("users").
    Columns(cols.Col("Name"), cols.Col("Email")).
    Values("Alice", "alice@example.com").
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// UPDATE
sql, args := qb.Update("users").
    Set(cols.Col("Name"), "Bob").
    Set(cols.Col("Email"), "bob@example.com").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// DELETE
sql, args := qb.Delete("users").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)
```

Access to vendor quirks (Oracle quoting, Mongo builders) routes through the same interface; switching drivers requires config only.

**Struct-Based Columns (v0.15.0+):**

```go
// Define entity once with db tags
type User struct {
    ID    int64  `db:"id"`
    Name  string `db:"name"`
    Level int    `db:"level"` // Oracle reserved word - auto-quoted
}

// Extract columns (cached per vendor)
cols := qb.Columns(&User{})

// SELECT with type-safe field references
query := qb.Select(cols.Fields("ID", "Name")...).
    From("users").
    Where(f.Eq(cols.Col("Level"), 5))
// Oracle: SELECT "ID", "NAME" FROM users WHERE "LEVEL" = :1
// PostgreSQL: SELECT id, name FROM users WHERE level = $1

// All columns: cols.All()
// Single column: cols.Col("FieldName")
// Multiple columns: cols.Fields("ID", "Name", "Email")
// Performance: ~0.6Âµs first parse, ~26ns cached access
```

**Table Aliases with Struct-Based Columns:**

```go
type User struct {
    ID     int64  `db:"id"`
    Name   string `db:"name"`
    Status string `db:"status"`
}

type Account struct {
    ID     int64  `db:"id"`
    Number string `db:"number"` // Oracle reserved word - auto-quoted
}

userCols := qb.Columns(&User{})
acctCols := qb.Columns(&Account{})

// Create aliased instances using As()
u := userCols.As("u")
a := acctCols.As("a")

jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select(
    u.Col("ID"),      // "u.id" or "u.\"ID\"" for Oracle
    u.Col("Name"),    // "u.name" or "u.\"NAME\"" for Oracle
    a.Col("Number"),  // "a.\"NUMBER\"" for Oracle (reserved word)
).
    From(dbtypes.Table("users").As("u")).
    JoinOn(dbtypes.Table("accounts").As("a"),
        jf.EqColumn(u.Col("ID"), a.Col("ID"))).
    Where(f.Eq(u.Col("Status"), "active"))
// Oracle: SELECT u."ID", u."NAME", a."NUMBER" FROM users u JOIN accounts a ON u."ID" = a."ID" WHERE u."STATUS" = :1
```

**Advanced JOIN Patterns:**

```go
// Mixed JOIN conditions: column-to-column + column-to-value with expressions
jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select("*").
    From(dbtypes.Table("orders").As("o")).
    JoinOn(dbtypes.Table("customers").As("c"), jf.And(
        jf.EqColumn("c.id", "o.customer_id"),       // Column-to-column
        jf.Eq("c.status", "active"),                 // Column-to-value
        jf.In("c.tier", []string{"gold", "platinum"}),
    )).
    JoinOn(dbtypes.Table("products").As("p"), jf.And(
        jf.EqColumn("p.id", "o.product_id"),
        jf.Eq("p.price", qb.Expr("TO_NUMBER(o.max_price)")), // Expression support
    )).
    Where(f.Eq("o.status", "pending"))
```

**Window Functions & Aggregations:**

```go
type Product struct {
    ProductID int64   `db:"product_id"`
    Price     float64 `db:"price"`
    Category  string  `db:"category"`
}
cols := qb.Columns(&Product{})

// Window function with PARTITION BY
query := qb.Select(
    cols.Col("ProductID"),
    cols.Col("Price"),
    qb.Expr("ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC)", "rank"),
).From("products")

// Aggregations with GROUP BY
query := qb.Select(
    cols.Col("Category"),
    qb.Expr("COUNT(*)", "product_count"),
    qb.Expr("AVG(price)", "avg_price"),
).From("products").GroupBy(cols.Col("Category"))
```

## Messaging Snapshot

```go
func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	exchange := decls.DeclareTopicExchange("orders.events")
	queue := decls.DeclareQueue("orders.processing")
	decls.DeclareBinding(queue.Name, exchange.Name, "order.*")

	decls.DeclarePublisher(&messaging.PublisherOptions{
		Exchange:   exchange.Name,
		RoutingKey: "order.created",
		EventType:  "OrderCreated",
	}, nil)

	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     queue.Name,
		Consumer:  "order-processor",
		EventType: "OrderCreated",
		Handler:   NewOrderHandler(m.svc, m.logger),
	}, nil)
}
```

| Concern            | Built-in support                                  |
|--------------------|---------------------------------------------------|
| Idempotent setup   | Declarations validated once, replayed per tenant  |
| Error handling     | **No automatic retry** - all errors drop message (prevents infinite loops). Rich ERROR logs + metrics for failed messages. DLQ support planned. |
| Publishers         | Typed options ensure routing key + event type     |
| Consumers          | Handler receives `context.Context`, `amqp.Delivery`; return error drops message |
| Metrics & tracing  | Automatic OTEL spans + structured logs            |

Use `messaging.Client.Publish(ctx, routingKey, payload)` for runtime sends.

**IMPORTANT:** Handler errors do NOT trigger retry. Failed messages are logged (ERROR level) with full context and dropped. Set up monitoring and alerts for failed message tracking.

## Multi-Tenancy
- Enable with `multitenant.enabled=true`.
- Resolution strategies: `header`, `host`, or custom store implementing `multitenant.Store`.
- Each tenant gets isolated DB connections, messaging clients, and module lifecycle events.

```yaml
multitenant:
  enabled: true
  tenant_resolution:
    strategy: header
    header_name: X-Tenant-ID
```

## Observability & Logging

```yaml
observability:
  enabled: true
  service_name: my-service
  trace: { enabled: true, endpoint: "http://otel-collector:4318", protocol: http }
  metrics: { enabled: true }
  logs:
    enabled: true
    slow_request_threshold: 750ms

logger:
  pretty: false # set false when exporting to OTLP
  level: info
```

Set `GOBRICKS_DEBUG=true` to emit `[OBSERVABILITY]` diagnostics during local runs.

## Common Patterns
- **Error handling**: wrap service errors with `server.InternalServerError`; map domain errors to `server.NotFound`, `server.Unauthorized`, etc.
- **Graceful shutdown**: close external resources in `Module.Shutdown`; the framework waits on outstanding requests.
- **Configuration injection**: `deps.Config.InjectInto(&cfgStruct)` honors defaults and env overrides.
- **Testing**: `obtest.NewTestTraceProvider()` captures spans/logs; mock `database.Interface` and `messaging.Client` directly.
