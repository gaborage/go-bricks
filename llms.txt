# GoBricks Framework

Enterprise Go microservice toolkit (Go 1.24+). Provides multi-database access, typed HTTP handlers, AMQP messaging, tenant isolation, and built-in OpenTelemetry.

## Quick Start
- `go get github.com/gaborage/go-bricks`
- Scaffold:

```go
package main

import (
	"log"

	"github.com/gaborage/go-bricks/app"
	"github.com/gaborage/go-bricks/config"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}
	fw, err := app.NewWithConfig(cfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	fw.RegisterModules(/* modules */)
	log.Fatal(fw.Run())
}
```

## Config Snapshot

```yaml
app:
  name: my-service
  environment: development
server:
  enabled: true
  port: 8080
database:
  type: postgres # postgres | oracle | mongo
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
logger:
  level: info
  pretty: true
```

`Highest precedence first: env vars > config.<env>.yaml > config.yaml > struct defaults.`
Add observability settings as needed (see Observability & Logging).

## Core Concepts
- Framework injects dependencies via `*app.ModuleDeps`; avoid constructing raw `*sql.DB`.
- Declarative messaging defines exchanges, queues, bindings, publishers, and consumers once; the framework replays per tenant.
- Observability hooks (traces, metrics, structured logs) activate when `observability.enabled=true`.
- Multi-tenant mode resolves tenants (header/host/custom store) and hands each module tenant-specific resources.

## Module Skeleton

```go
type Module struct {
	db     database.Interface
	logger logger.Logger
}

func (m *Module) Name() string { return "mymodule" }

func (m *Module) Init(deps *app.ModuleDeps) error {
	m.db = deps.DB
	m.logger = deps.Logger.WithFields(map[string]any{"module": m.Name()})
	return nil
}

func (m *Module) RegisterRoutes(hr *server.HandlerRegistry, e *echo.Echo) {
	handler := NewHandler(m.db, m.logger)
	server.POST(hr, e, "/users", handler.Create)
}

func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	// optional
}

func (m *Module) Shutdown() error { return nil }
```

## Typed HTTP Handlers

```go
type CreateUserReq struct {
	Name  string `json:"name" validate:"required"`
	Email string `json:"email" validate:"required,email"`
}

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (h *Handler) Create(req CreateUserReq, ctx server.HandlerContext) (server.Result[User], server.IAPIError) {
	reqCtx := ctx.Request().Context()
	user, err := h.svc.Create(reqCtx, req)
	if err != nil {
		return server.Result[User]{}, server.InternalServerError(err)
	}
	return server.Created(user), nil
}
```

| Pattern          | Request binding              | Success helper          | Notes                          |
|------------------|------------------------------|-------------------------|--------------------------------|
| POST create      | JSON struct w/ validators    | `server.Created(data)`  | 422 auto-emitted on validation |
| GET lookup       | `server.NoBody` + `ctx.Param`| `server.OK(data)`       | Return domain errors as API    |
| LIST with query  | `query:"..."` struct tags    | `server.OK(list)`       | Query params auto-bound        |
| DELETE           | `server.NoBody`              | `server.NoContent()`    | Return typed API errors        |
| ASYNC acceptance | Request struct               | `server.Accepted(meta)` | For enqueue-style workflows    |

### Pointer Types for Large Payloads

Use **pointer types** for requests/responses >1KB to eliminate copy overhead. Fully backward compatible.

```go
// Large request - file upload (pointer avoids copying MB of data)
type FileUploadRequest struct {
	Data     []byte `json:"data" validate:"required"` // Base64-encoded file
	Filename string `json:"filename" validate:"required"`
	MimeType string `json:"mime_type"`
}

func (h *Handler) UploadFile(req *FileUploadRequest, ctx server.HandlerContext) (server.Result[UploadResponse], server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	fileID, err := h.storageService.Store(reqCtx, req.Data, req.Filename, req.MimeType)
	if err != nil {
		return server.Result[UploadResponse]{}, server.InternalServerError(err)
	}
	return server.Created(UploadResponse{FileID: fileID, Size: len(req.Data)}), nil
}

// Large response - bulk export (pointer avoids copying thousands of records)
type BulkExportResponse struct {
	Records []Record `json:"records"`
	Total   int      `json:"total"`
	Page    int      `json:"page"`
}

func (h *Handler) ExportRecords(req ExportRequest, ctx server.HandlerContext) (*BulkExportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	records, err := h.recordService.GetAll(reqCtx, req.Filter)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkExportResponse{
		Records: records,
		Total:   len(records),
		Page:    req.Page,
	}, nil
}

// Both pointer types - bulk import handler
type BulkImportRequest struct {
	Records []ImportRecord `json:"records" validate:"required,min=1,max=10000"`
	DryRun  bool           `json:"dry_run"`
}

type BulkImportResponse struct {
	Imported int      `json:"imported"`
	Failed   int      `json:"failed"`
	Errors   []string `json:"errors,omitempty"`
}

func (h *Handler) BulkImport(req *BulkImportRequest, ctx server.HandlerContext) (*BulkImportResponse, server.IAPIError) {
	reqCtx := ctx.Echo.Request().Context()
	result, err := h.importService.ProcessBulk(reqCtx, req.Records, req.DryRun)
	if err != nil {
		return nil, server.InternalServerError(err)
	}
	return &BulkImportResponse{
		Imported: result.Imported,
		Failed:   result.Failed,
		Errors:   result.Errors,
	}, nil
}
```

**Performance guidelines:**
- **<1KB**: Use value types (default, idiomatic Go)
- **1KB-10KB**: Consider pointers for high-traffic endpoints
- **>10KB**: Always use pointers (file uploads, bulk operations)
- Pointer fields (`*string`, `*int`) work correctly with validation (`omitempty`, `min=`)

## Database Builder & Operations

```go
// Define entity with db tags
type User struct {
    ID     int64  `db:"id"`
    Email  string `db:"email"`
    Status string `db:"status"`
}

qb := builder.NewQueryBuilder(m.db.DatabaseType())
f := qb.Filter()
cols := qb.Columns(&User{})

sql, args := qb.Select(cols.Fields("ID", "Email")...).
	From("users").
	Where(f.And(
		f.Eq(cols.Col("Status"), "active"),
		f.Like(cols.Col("Email"), "%@example.com"),
	)).
	ToSQL()

ctx := context.Background() // or propagate incoming request context
rows, err := m.db.Query(ctx, sql, args...)
```

| Need                | Builder call / API usage                                               |
|---------------------|------------------------------------------------------------------------|
| Filtering           | `f.Eq`, `f.And`, `f.Or`, `f.In`, `f.Between`                           |
| Sorting / grouping  | `qb.Select(...).From("...").OrderBy(qb.Expr("created_at DESC")).GroupBy("tenant_id")` |
| Mutations           | `qb.Insert`, `qb.Update`, `qb.Delete`, then `db.Exec`                  |
| Joins               | `qb.JoinOn` with `qb.JoinFilter()`                                     |
| Subqueries          | Compose another builder clause then `f.Exists(subQuery)`               |
| Transactions        | `tx, err := db.Begin(ctx); if err != nil { return err }; defer tx.Rollback(ctx); /* work */; if err := tx.Commit(ctx); err != nil { return err }` |

**Mutation Examples (INSERT/UPDATE/DELETE):**

```go
// INSERT
sql, args := qb.Insert("users").
    Columns(cols.Col("Name"), cols.Col("Email")).
    Values("Alice", "alice@example.com").
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// UPDATE
sql, args := qb.Update("users").
    Set(cols.Col("Name"), "Bob").
    Set(cols.Col("Email"), "bob@example.com").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)

// DELETE
sql, args := qb.Delete("users").
    Where(f.Eq(cols.Col("ID"), 123)).
    ToSQL()
result, err := m.db.Exec(ctx, sql, args...)
```

Access to vendor quirks (Oracle quoting, Mongo builders) routes through the same interface; switching drivers requires config only.

**Struct-Based Columns (v0.15.0+):**

```go
// Define entity once with db tags
type User struct {
    ID    int64  `db:"id"`
    Name  string `db:"name"`
    Level int    `db:"level"` // Oracle reserved word - auto-quoted
}

// Extract columns (cached per vendor)
cols := qb.Columns(&User{})

// SELECT with type-safe field references
query := qb.Select(cols.Fields("ID", "Name")...).
    From("users").
    Where(f.Eq(cols.Col("Level"), 5))
// Oracle: SELECT "ID", "NAME" FROM users WHERE "LEVEL" = :1
// PostgreSQL: SELECT id, name FROM users WHERE level = $1

// All columns: cols.All()
// Single column: cols.Col("FieldName")
// Multiple columns: cols.Fields("ID", "Name", "Email")
// Performance: ~0.6µs first parse, ~26ns cached access
```

**Table Aliases with Struct-Based Columns:**

```go
type User struct {
    ID     int64  `db:"id"`
    Name   string `db:"name"`
    Status string `db:"status"`
}

type Account struct {
    ID     int64  `db:"id"`
    Number string `db:"number"` // Oracle reserved word - auto-quoted
}

userCols := qb.Columns(&User{})
acctCols := qb.Columns(&Account{})

// Create aliased instances using As()
u := userCols.As("u")
a := acctCols.As("a")

jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select(
    u.Col("ID"),      // "u.id" or "u.\"ID\"" for Oracle
    u.Col("Name"),    // "u.name" or "u.\"NAME\"" for Oracle
    a.Col("Number"),  // "a.\"NUMBER\"" for Oracle (reserved word)
).
    From(dbtypes.Table("users").As("u")).
    JoinOn(dbtypes.Table("accounts").As("a"),
        jf.EqColumn(u.Col("ID"), a.Col("ID"))).
    Where(f.Eq(u.Col("Status"), "active"))
// Oracle: SELECT u."ID", u."NAME", a."NUMBER" FROM users u JOIN accounts a ON u."ID" = a."ID" WHERE u."STATUS" = :1
```

**Advanced JOIN Patterns:**

```go
// Mixed JOIN conditions: column-to-column + column-to-value with expressions
jf := qb.JoinFilter()
f := qb.Filter()

query := qb.Select("*").
    From(dbtypes.Table("orders").As("o")).
    JoinOn(dbtypes.Table("customers").As("c"), jf.And(
        jf.EqColumn("c.id", "o.customer_id"),       // Column-to-column
        jf.Eq("c.status", "active"),                 // Column-to-value
        jf.In("c.tier", []string{"gold", "platinum"}),
    )).
    JoinOn(dbtypes.Table("products").As("p"), jf.And(
        jf.EqColumn("p.id", "o.product_id"),
        jf.Eq("p.price", qb.Expr("TO_NUMBER(o.max_price)")), // Expression support
    )).
    Where(f.Eq("o.status", "pending"))
```

**Window Functions & Aggregations:**

```go
type Product struct {
    ProductID int64   `db:"product_id"`
    Price     float64 `db:"price"`
    Category  string  `db:"category"`
}
cols := qb.Columns(&Product{})

// Window function with PARTITION BY
query := qb.Select(
    cols.Col("ProductID"),
    cols.Col("Price"),
    qb.Expr("ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC)", "rank"),
).From("products")

// Aggregations with GROUP BY
query := qb.Select(
    cols.Col("Category"),
    qb.Expr("COUNT(*)", "product_count"),
    qb.Expr("AVG(price)", "avg_price"),
).From("products").GroupBy(cols.Col("Category"))
```

## Database Testing

> **⚠️ IMPORTANT RESOURCE MANAGEMENT:**
> When using `Query()` or `TestTx.Query()`, **ALWAYS call `defer rows.Close()`** immediately after obtaining rows.
> The returned `*sql.Rows` is backed by a temporary `*sql.DB` that must be explicitly closed to prevent resource leaks.
> A finalizer provides a safety net, but **explicit cleanup via `defer` is mandatory** for deterministic resource management.

**Simple Query Test:**

```go
import dbtest "github.com/gaborage/go-bricks/database/testing"

func TestProductService_FindActive(t *testing.T) {
    // Setup (8 lines vs 30+ with sqlmock)
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewProductService(deps)
    products, err := svc.FindActive(ctx)

    assert.NoError(t, err)
    assert.Len(t, products, 2)
dbtest.AssertQueryExecuted(t, db, "SELECT")
}
```

**Iterating Rows with `Query`:**

```go
func TestProductRepository_List(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    db.ExpectQuery("SELECT").
        WillReturnRows(
            dbtest.NewRowSet("id", "name").
                AddRow(int64(1), "Widget").
                AddRow(int64(2), "Gadget"),
        )

    rows, err := db.Query(context.Background(), "SELECT id, name FROM products")
    require.NoError(t, err)
    defer rows.Close()

    var got []Product
    for rows.Next() {
        var p Product
        require.NoError(t, rows.Scan(&p.ID, &p.Name))
        got = append(got, p)
    }

    require.NoError(t, rows.Err())
    assert.Len(t, got, 2)
}
```

**Transaction Test:**

```go
func TestOrderService_CreateWithItems(t *testing.T) {
    db := dbtest.NewTestDB(dbtypes.PostgreSQL)
    tx := db.ExpectTransaction().
        ExpectExec("INSERT INTO orders").WillReturnRowsAffected(1).
        ExpectExec("INSERT INTO items").WillReturnRowsAffected(3)

    deps := &app.ModuleDeps{
        GetDB: func(ctx context.Context) (database.Interface, error) {
            return db, nil
        },
    }

    svc := NewOrderService(deps)
    err := svc.CreateWithItems(ctx, order, items)

    assert.NoError(t, err)
    dbtest.AssertCommitted(t, tx)
}
```

**Multi-Tenant Test:**

```go
func TestMultiTenantService(t *testing.T) {
    tenants := dbtest.NewTenantDBMap()

    // Setup tenant-specific expectations
    tenants.ForTenant("acme").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(1)),
        )
    tenants.ForTenant("globex").
        ExpectQuery("SELECT").WillReturnRows(
            dbtest.NewRowSet("id").AddRow(int64(2)),
        )

    deps := &app.ModuleDeps{
        GetDB: tenants.AsGetDBFunc(),  // Resolves tenant from ctx
    }

    // Test with tenant context
    ctx := multitenant.SetTenant(context.Background(), "acme")
    result, err := svc.Process(ctx)

    assert.NoError(t, err)
    dbtest.AssertQueryExecuted(t, tenants.GetTenantDB("acme"), "SELECT")
}
```

**RowSet Builders:**

```go
// From structs with db tags
type User struct {
    ID   int64  `db:"id"`
    Name string `db:"name"`
}

rows := dbtest.NewRowSet("id", "name").
    AddRowsFromStructs(
        &User{ID: 1, Name: "Alice"},
        &User{ID: 2, Name: "Bob"},
    )

// With generator function
rows := dbtest.NewRowSet("id", "name").
    AddRows(100, func(i int) []any {
        return []any{int64(i+1), fmt.Sprintf("User%d", i+1)}
    })

// RowSet powers both Query() and QueryRow() expectations. It now materializes
// real *sql.Rows under the hood, so you can iterate using database/sql's
// standard pattern. Supported value types include integers, floats, bools,
// strings, []byte, time.Time, fmt.Stringer, and nil.
```

**Assertion Helpers:**

```go
dbtest.AssertQueryExecuted(t, db, "SELECT")
dbtest.AssertQueryCount(t, db, "SELECT", 2)
dbtest.AssertExecExecuted(t, db, "INSERT")
dbtest.AssertTransactionCommitted(t, db)
dbtest.AssertTransactionRolledBack(t, db)
```

See [database/testing](database/testing/) package for full API documentation.

## Cache Operations (Redis)

**Configuration:**

```yaml
cache:
  enabled: true
  type: redis
  redis:
    host: localhost
    port: 6379
    password: ${CACHE_REDIS_PASSWORD} # from env
    database: 0
    pool_size: 10
```

**Basic Cache Operations:**

```go
import (
    "github.com/gaborage/go-bricks/cache"
    "github.com/gaborage/go-bricks/cache/redis"
)

// Module setup
type Module struct {
    cache cache.Cache
}

func (m *Module) Init(deps *app.ModuleDeps) error {
    // Get tenant-specific cache instance
    c, err := deps.GetCache(ctx)
    if err != nil {
        return err
    }
    m.cache = c
    return nil
}

// Basic operations
ctx := context.Background()

// Set with TTL
err := m.cache.Set(ctx, "user:123", []byte("data"), 5*time.Minute)

// Get
data, err := m.cache.Get(ctx, "user:123")
if errors.Is(err, cache.ErrNotFound) {
    // Key doesn't exist - fetch from database
}

// Delete
err := m.cache.Delete(ctx, "user:123")
```

**Type-Safe Serialization:**

```go
import "github.com/gaborage/go-bricks/cache"

type User struct {
    ID    int64  `cbor:"1,keyasint"` // Optimized: integer keys
    Name  string `cbor:"2,keyasint"`
    Email string `cbor:"3,keyasint"`
}

// Serialize and cache
user := User{ID: 123, Name: "Alice", Email: "alice@example.com"}
data, err := cache.Marshal(user)
if err != nil {
    return err
}
err = m.cache.Set(ctx, "user:123", data, 5*time.Minute)

// Retrieve and deserialize
data, err := m.cache.Get(ctx, "user:123")
if err != nil {
    return err
}
user, err := cache.Unmarshal[User](data)
```

**Query Result Caching Pattern:**

```go
func (s *UserService) GetUser(ctx context.Context, id int64) (*User, error) {
    cacheKey := fmt.Sprintf("user:%d", id)

    // Try cache first
    data, err := s.cache.Get(ctx, cacheKey)
    if err == nil {
        return cache.Unmarshal[User](data)
    }

    // Cache miss - query database
    user, err := s.queryDatabase(ctx, id)
    if err != nil {
        return nil, err
    }

    // Store in cache for future requests
    data, _ = cache.Marshal(user)
    s.cache.Set(ctx, cacheKey, data, 5*time.Minute)

    return user, nil
}
```

**Deduplication with GetOrSet:**

```go
// Atomic deduplication for idempotency keys
idempotencyKey := "process:batch:abc-123"
taskData := []byte("task-payload")

storedValue, wasSet, err := m.cache.GetOrSet(ctx, idempotencyKey, taskData, 10*time.Minute)
if err != nil {
    return err
}

if wasSet {
    // First time processing - execute task
    return processBatch(ctx, taskData)
}

// Duplicate request detected - return cached result
return getCachedResult(storedValue)
```

**Distributed Locking with CompareAndSet:**

```go
// Acquire distributed lock
lockKey := "lock:job:456"
workerID := []byte("worker-1")

success, err := m.cache.CompareAndSet(ctx, lockKey, nil, workerID, 30*time.Second)
if err != nil {
    return err
}

if !success {
    return errors.New("lock already held by another worker")
}

// Lock acquired - perform work
defer m.cache.Delete(ctx, lockKey) // Release lock

return processJob(ctx)
```

| Operation       | Use Case                          | Atomicity      |
|-----------------|-----------------------------------|----------------|
| Get/Set/Delete  | Basic caching                     | Single-key     |
| GetOrSet        | Idempotency, deduplication        | Atomic SET NX  |
| CompareAndSet   | Distributed locks, optimistic CAS | Lua script     |
| Marshal/Unmarshal | Type-safe serialization         | CBOR encoding  |

**Error Handling:**

```go
data, err := m.cache.Get(ctx, key)
if errors.Is(err, cache.ErrNotFound) {
    // Key doesn't exist
} else if errors.Is(err, cache.ErrClosed) {
    // Cache connection closed
} else if opErr, ok := err.(*cache.OperationError); ok {
    // Cache operation failed - includes operation, key, underlying error
    log.Error(opErr.Op, opErr.Key, opErr.Err)
}
```

## Messaging Snapshot

```go
func (m *Module) DeclareMessaging(decls *messaging.Declarations) {
	exchange := decls.DeclareTopicExchange("orders.events")
	queue := decls.DeclareQueue("orders.processing")
	decls.DeclareBinding(queue.Name, exchange.Name, "order.*")

	decls.DeclarePublisher(&messaging.PublisherOptions{
		Exchange:   exchange.Name,
		RoutingKey: "order.created",
		EventType:  "OrderCreated",
	}, nil)

	decls.DeclareConsumer(&messaging.ConsumerOptions{
		Queue:     queue.Name,
		Consumer:  "order-processor",
		EventType: "OrderCreated",
		Handler:   NewOrderHandler(m.svc, m.logger),
	}, nil)
}
```

| Concern            | Built-in support                                  |
|--------------------|---------------------------------------------------|
| Idempotent setup   | Declarations validated once, replayed per tenant  |
| Error handling     | **No automatic retry** - all errors drop message (prevents infinite loops). Rich ERROR logs + metrics for failed messages. DLQ support planned. |
| Publishers         | Typed options ensure routing key + event type     |
| Consumers          | Handler receives `context.Context`, `amqp.Delivery`; return error drops message |
| Metrics & tracing  | Automatic OTEL spans + structured logs            |

Use `messaging.Client.Publish(ctx, routingKey, payload)` for runtime sends.

**IMPORTANT:** Handler errors do NOT trigger retry. Failed messages are logged (ERROR level) with full context and dropped. Set up monitoring and alerts for failed message tracking.

## Multi-Tenancy
- Enable with `multitenant.enabled=true`.
- Resolution strategies: `header`, `host`, or custom store implementing `multitenant.Store`.
- Each tenant gets isolated DB connections, messaging clients, and module lifecycle events.

```yaml
multitenant:
  enabled: true
  tenant_resolution:
    strategy: header
    header_name: X-Tenant-ID
```

## Observability & Logging

```yaml
observability:
  enabled: true
  service_name: my-service
  trace: { enabled: true, endpoint: "http://otel-collector:4318", protocol: http }
  metrics: { enabled: true }
  logs:
    enabled: true
    slow_request_threshold: 750ms

logger:
  pretty: false # set false when exporting to OTLP
  level: info
```

Set `GOBRICKS_DEBUG=true` to emit `[OBSERVABILITY]` diagnostics during local runs.

## Common Patterns
- **Error handling**: wrap service errors with `server.InternalServerError`; map domain errors to `server.NotFound`, `server.Unauthorized`, etc.
- **Graceful shutdown**: close external resources in `Module.Shutdown`; the framework waits on outstanding requests.
- **Configuration injection**: `deps.Config.InjectInto(&cfgStruct)` honors defaults and env overrides.
- **Testing**: `obtest.NewTestTraceProvider()` captures spans/logs; mock `database.Interface` and `messaging.Client` directly.
