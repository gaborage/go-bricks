# ADR-005: Type-Safe WHERE Clause Construction

**Date:** 2025-09-27
**Status:** Accepted
**Context:** Oracle identifier quoting reliability and SQL injection prevention

## Problem Statement

The framework's query builder allowed raw string WHERE clauses that could bypass Oracle identifier quoting, leading to runtime SQL errors when reserved words were used unquoted:

```sql
-- Problematic query generated by: qb.Select("id", "number").Where("number = ?", value)
SELECT id, "number" FROM accounts WHERE number = :1
                                        ^^^^^^ unquoted reserved word
-- Results in: ORA-00936: missing expression at position 103
```

This issue occurred because:
1. **Inconsistent Quoting**: SELECT clause properly quoted "number" but WHERE clause did not
2. **Runtime Failures**: Errors only surfaced during query execution, not at compile time
3. **Developer Confusion**: Inconsistent behavior between different SQL vendors
4. **Maintenance Burden**: Required developers to remember Oracle-specific quoting rules

## Options Considered

### Option 1: WHERE Clause Parser (Rejected)
- Parse string-based WHERE clauses to identify and quote column names
- Maintain backward compatibility with string-based API
- **Rejected**: Complex implementation, potential parsing edge cases, runtime overhead

### Option 2: Enhanced Documentation (Rejected)
- Improve documentation about Oracle quoting requirements
- Provide more examples of correct usage
- **Rejected**: Does not prevent the fundamental issue, relies on developer memory

### Option 3: Type-Safe WHERE Methods (CHOSEN)
- Remove `.Where()` method entirely
- Implement type-safe methods like `WhereEq()`, `WhereLt()`, etc.
- Provide `WhereRaw()` escape hatch with clear documentation
- **Chosen**: Compile-time safety, impossible to bypass quoting accidentally

## Decision

**We chose Option 3: Type-Safe WHERE Methods** with the following implementation:

### Core Design Principles
1. **Compile-Time Safety**: Prevent unquoted identifier issues at build time
2. **Clear Responsibility**: Explicit methods vs. escape hatch with documented risks
3. **Oracle-First**: Design that works reliably with Oracle's quoting requirements
4. **Zero Ambiguity**: No possibility of accidentally bypassing safety mechanisms

### New SelectQueryBuilder API
```go
// Type-safe methods (automatically handle quoting)
.WhereEq(column, value)           // column = value
.WhereNotEq(column, value)        // column <> value
.WhereLt(column, value)           // column < value
.WhereGt(column, value)           // column > value
.WhereIn(column, values)          // column IN (...)
.WhereNull(column)                // column IS NULL
.WhereBetween(column, min, max)   // column BETWEEN min AND max

// Escape hatch (user responsibility for quoting)
.WhereRaw(condition, args...)     // Raw SQL with manual quoting
```

### Architecture Changes
1. **SelectQueryBuilder**: New wrapper around squirrel.SelectBuilder
2. **Method Delegation**: All squirrel methods (Join, OrderBy, etc.) delegated through wrapper
3. **Quoting Integration**: Type-safe methods use existing `qb.Eq()`, `qb.Lt()` infrastructure
4. **Breaking Change**: `.Where()` method completely removed (no deprecation period)

## Implementation Details

### Technical Components

**Core Architecture**:
```go
type SelectQueryBuilder struct {
    qb            *QueryBuilder
    selectBuilder squirrel.SelectBuilder
}

func (qb *QueryBuilder) Select(columns ...string) *SelectQueryBuilder {
    return &SelectQueryBuilder{
        qb:            qb,
        selectBuilder: qb.statementBuilder.Select(qb.quoteColumnsForSelect(columns...)...),
    }
}
```

**Type-Safe WHERE Implementation**:
```go
func (sqb *SelectQueryBuilder) WhereEq(column string, value any) *SelectQueryBuilder {
    sqb.selectBuilder = sqb.selectBuilder.Where(sqb.qb.Eq(column, value))
    return sqb
}
```

**Clear Escape Hatch Documentation**:
```go
// WhereRaw adds a raw SQL WHERE condition to the query.
//
// WARNING: This method bypasses all identifier quoting and SQL injection protection.
// It is the caller's responsibility to:
//   - Properly quote any identifiers (especially Oracle reserved words)
//   - Ensure the SQL fragment is valid for the target database
//   - Never concatenate user input directly into the condition string
func (sqb *SelectQueryBuilder) WhereRaw(condition string, args ...any) *SelectQueryBuilder
```

### Testing Strategy
1. **Comprehensive Oracle Tests**: All Oracle reserved words tested with type-safe methods
2. **Original Bug Reproduction**: Specific test demonstrating the fix for the exact error
3. **Escape Hatch Tests**: WhereRaw functionality with manual quoting examples
4. **Backward Compatibility**: All existing tests updated to use new API

## Migration Strategy

### Breaking Change Implementation
- **No Deprecation Period**: Immediate breaking change for compile-time safety
- **Clear Error Messages**: Compilation errors guide developers to correct methods
- **Comprehensive Examples**: Documentation shows exact replacements

### Migration Patterns
```go
// OLD (no longer compiles)
.Where("number = ?", value)
.Where("level > ?", minLevel)
.Where("status IN (?)", statuses)

// NEW (required)
.WhereEq("number", value)
.WhereGt("level", minLevel)
.WhereIn("status", statuses)

// Complex conditions use WhereRaw with manual quoting
.WhereRaw(`"number" = ? AND ROWNUM <= ?`, value, 10)
```

## Consequences

### Positive
- **Eliminates Oracle Quoting Bugs**: Impossible to accidentally create unquoted WHERE clauses
- **Compile-Time Safety**: Errors caught during build, not runtime
- **Clear Responsibility Boundaries**: Type-safe methods vs. explicit escape hatch
- **Improved Developer Experience**: No need to remember Oracle quoting rules
- **Future-Proof**: Easy to add new type-safe methods as needed
- **Self-Documenting Code**: Method names clearly indicate operation type

### Negative
- **Breaking Change**: All existing `.Where()` usage requires migration
- **Learning Curve**: Developers must learn new API methods
- **Verbosity**: Some complex conditions require multiple method calls
- **Migration Effort**: Existing codebases need comprehensive updates

### Neutral
- **Performance**: No runtime impact, compile-time code generation
- **Memory**: Minimal wrapper overhead
- **Dependencies**: No new external dependencies required

## Quality Assurance

### Testing Coverage
- **Oracle Reserved Words**: Comprehensive testing with 20+ reserved words
- **All Operators**: Coverage for =, <>, <, <=, >, >=, IN, NOT IN, IS NULL
- **Edge Cases**: Complex queries, nested conditions, function calls
- **Regression**: Original bug scenario specifically tested and verified fixed

### Code Quality
- **Type Safety**: Full Go type checking throughout query construction
- **Documentation**: Extensive inline documentation with examples
- **Error Handling**: Clear error messages for incorrect usage
- **Performance**: Zero runtime overhead for type-safe methods

## Success Metrics

1. **Zero Oracle Quoting Errors**: No ORA-00936 errors related to unquoted identifiers
2. **Compilation Safety**: All identifier quoting issues caught at build time
3. **Developer Adoption**: Type-safe methods used over WhereRaw in 90%+ of cases
4. **Migration Completeness**: All framework tests pass with new API

## Future Considerations

- **Additional Operators**: Add more type-safe methods as needed (LIKE patterns, EXISTS, etc.)
- **Query Validation**: Consider static analysis tools for WhereRaw usage
- **Code Generation**: Tooling to assist with migration from old API
- **Documentation**: Interactive examples and best practices guide

---

*This ADR represents a significant shift toward compile-time safety and Oracle-first design, prioritizing reliability over backward compatibility to prevent an entire class of runtime SQL errors.*
